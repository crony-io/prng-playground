{
  "app": {
    "title": "PRNG School",
    "description": "Aprende c√≥mo los algoritmos PRNG transforman estado, semilla y entrop√≠a ‚Äî interactivamente.",
    "welcome": {
      "badge": "Bienvenido",
      "title": "Generador de n√∫meros pseudoaleatorios",
      "description": "Aprende c√≥mo los algoritmos PRNG transforman estado, semilla y entrop√≠a ‚Äî interactivamente."
    }
  },
  "common": {
    "generate": "Generar",
    "copy": "Copiar",
    "save": "Guardar",
    "cancel": "Cancelar",
    "close": "Cerrar",
    "delete": "Eliminar",
    "loading": "Cargando...",
    "success": "¬°√âxito!",
    "error": "Error",
    "warning": "Advertencia",
    "unknown": "Desconocido",
    "unknownError": "Error desconocido"
  },
  "prngRunner": {
    "errors": {
      "algorithmNotFound": "Algoritmo \"{id}\" no encontrado",
      "failedToInitialize": "No se pudo inicializar",
      "invalidValue": "El generador produjo un valor inv√°lido (NaN o infinito)",
      "valueOutOfRange": "Valor fuera de rango [0, 1): {value}",
      "stepFailed": "Fall√≥ el paso"
    }
  },
  "theme": {
    "selector": {
      "aria_label": "Cambiar tema a {theme}"
    },
    "options": {
      "light": "Claro",
      "dark": "Oscuro",
      "system": "Sistema"
    }
  },
  "language": {
    "selector": {
      "aria_label": "Cambiar idioma a {language}"
    }
  },
  "navigation": {
    "home": "Inicio",
    "learn": "Aprender",
    "about": "Acerca de",
    "workshop": "Taller"
  },
  "workshop": {
    "title": "Taller de Algoritmos",
    "description": "Crea, edita y experimenta con tus propios algoritmos PRNG",
    "showHelp": "Ayuda",
    "hideHelp": "Ocultar Ayuda",
    "createNew": "Nuevo Algoritmo",
    "algorithms": "Tus Algoritmos",
    "noAlgorithms": "A√∫n no hay algoritmos. ¬°Crea el primero!",
    "untitled": "Sin t√≠tulo",
    "forkedFrom": "Derivado de",
    "fork": "Derivar",
    "custom": "Personalizado",
    "editor": "Editor",
    "name": "Nombre",
    "namePlaceholder": "Mi PRNG",
    "algorithmDescription": "Descripci√≥n",
    "descriptionPlaceholder": "Describe tu algoritmo...",
    "stateVariables": "Variables de Estado",
    "addVariable": "Agregar Variable",
    "outputVariable": "Variable de Salida",
    "operations": "Operaciones",
    "addOperation": "Agregar Operaci√≥n",
    "customConst": "Personalizado...",
    "preview": "Vista Previa",
    "forkBuiltin": "Derivar de Predefinido",
    "testSeed": "Semilla de Prueba",
    "runSize": "Tama√±o de Ejecuci√≥n",
    "autoDuration": "Auto (s)",
    "moveUp": "Mover arriba",
    "moveDown": "Mover abajo",
    "editorModes": {
      "visual": "Visual",
      "code": "C√≥digo"
    },
    "codeEditor": {
      "label": "C√≥digo de Operaciones",
      "placeholder": "s = s + 1\ns = s ^ 0x9e3779b9\ns = s >>> 13\ns = rotl(s, 5)",
      "format": "Formatear",
      "revert": "Revertir",
      "apply": "Aplicar",
      "newVariables": "Se crear√°n nuevas variables (valor inicial 0): {vars}",
      "errorAt": "L√≠nea {line}, Col {column}: {message}",
      "toast": {
        "applied": "Aplicado",
        "fixErrorsBeforeApply": "Corrige los errores antes de aplicar",
        "fixErrorsBeforeFormat": "Corrige los errores antes de formatear",
        "needOneOperation": "Agrega al menos una operaci√≥n"
      },
      "errors": {
        "invalid_statement": "Sentencia inv√°lida (se espera: objetivo = expresi√≥n)",
        "invalid_target": "Objetivo inv√°lido: {target}",
        "invalid_expression": "Expresi√≥n inv√°lida",
        "invalid_operand": "Operando inv√°lido: {token}",
        "invalid_number": "N√∫mero inv√°lido: {token}",
        "amount_must_be_number": "La cantidad de desplazamiento/rotaci√≥n debe ser un n√∫mero (0-31): {token}",
        "amount_out_of_range": "Cantidad de desplazamiento/rotaci√≥n fuera de rango (0-31): {amount}",
        "unsupported_operator": "Operador no soportado: {operator}",
        "unsupported_function": "Funci√≥n no soportada",
        "unknown": "Error desconocido"
      }
    },
    "previewTabs": {
      "state": "Estado",
      "charts": "Gr√°ficos",
      "tests": "Pruebas"
    },
    "previewPanel": {
      "stateEmpty": "Haz clic en {action} para generar muestras",
      "chartsEmpty": "Ejecuta el algoritmo para ver visualizaciones"
    },
    "autoTests": {
      "title": "Pruebas de Calidad",
      "runTests": "Ejecutar Pruebas",
      "mean": "Media",
      "variance": "Varianza",
      "expected": "esperado",
      "chiSquare": "Chi-Cuadrado",
      "bitBias": "Sesgo de Bits",
      "pass": "PASA",
      "warn": "ALERTA",
      "fail": "FALLA",
      "needSamples": "Se necesitan 1000+ muestras para ejecutar pruebas"
    },
    "templates": {
      "selectTemplate": "Selecciona una plantilla para derivar:",
      "forkAs": "Derivar como:",
      "defaultForkName": "Mi {name}"
    },
    "seed": {
      "label": "Semilla",
      "placeholder": "Ingrese valor de semilla"
    },
    "sampleSize": {
      "label": "Tama√±o de Muestra"
    },
    "controls": {
      "step": "Paso",
      "run": "Ejecutar",
      "autorun": "Auto",
      "stop": "Detener",
      "reset": "Reiniciar"
    },
    "algorithm": {
      "recommended": "Recomendado",
      "warnings": "Advertencias",
      "references": "Referencias"
    },
    "state": {
      "title": "Estado Interno",
      "stepCount": "Pasos",
      "empty": "Ejecuta un paso para ver el estado",
      "changed": "cambi√≥"
    },
    "output": {
      "title": "Salida",
      "lastValue": "√öltimo Valor",
      "noSamples": "A√∫n no se han generado muestras"
    },
    "histogram": {
      "title": "Distribuci√≥n",
      "yAxisLabel": "conteo",
      "empty": "Sin datos"
    },
    "correlation": {
      "title": "Gr√°fico de Correlaci√≥n",
      "xAxisLabel": "r[i]",
      "yAxisLabel": "r[i+1]",
      "empty": "Se necesitan 2+ muestras"
    },
    "timeSeries": {
      "title": "Serie Temporal",
      "xAxisLabel": "muestra #",
      "empty": "Sin datos"
    }
  },
  "footer": {
    "github": {
      "label": "GitHub",
      "aria_label": "Abrir repositorio de GitHub"
    }
  },
  "about": {
    "description": "Aprende c√≥mo los algoritmos PRNG transforman estado, semilla y entrop√≠a ‚Äî interactivamente."
  },
  "algorithms": {
    "tags": {
      "fast": "R√°pido",
      "modern": "Moderno",
      "educational": "Educativo",
      "legacy": "Legado"
    },
    "sfc32": {
      "name": "SFC32",
      "description": "Small Fast Counter - PRNG con estado de 128 bits. Pasa PractRand y BigCrush. Excelente calidad y velocidad.",
      "recommended": "Uso general, simulaciones, juegos"
    },
    "mulberry32": {
      "name": "Mulberry32",
      "description": "PRNG minimalista con estado de 32 bits. Muy r√°pido, pasa pruebas gjrand. Per√≠odo ~4 mil millones.",
      "recommended": "N√∫meros aleatorios r√°pidos cuando el tama√±o del estado importa",
      "warning": "Puede omitir aproximadamente 1/3 de todos los valores de 32 bits"
    },
    "splitmix32": {
      "name": "SplitMix32",
      "description": "Basado en el finalizador fmix32 de MurmurHash3. Estado de 32 bits, muy r√°pido.",
      "recommended": "Sembrar otros PRNGs, aplicaciones basadas en hash"
    },
    "xorshift32": {
      "name": "Xorshift32",
      "description": "Xorshift original de 32 bits de Marsaglia (2003). Estructura simple, valor educativo.",
      "recommended": "Aprender fundamentos de PRNG",
      "warning": "Falla muchas pruebas estad√≠sticas modernas. No para uso en producci√≥n."
    },
    "xoshiro128ss": {
      "name": "xoshiro128**",
      "description": "Derivado moderno de Xorshift (2018). Estado de 128 bits, r√°pido, buena calidad.",
      "recommended": "Uso general cuando se prefiere la familia xorshift",
      "warning": "Tiene problemas relacionados con LFSR en bits inferiores"
    },
    "lcg": {
      "name": "LCG (Park-Miller)",
      "description": "Generador Congruencial Lineal con par√°metros MINSTD. PRNG educativo cl√°sico.",
      "recommended": "Aprender sobre estructura y debilidades de PRNG",
      "warning": "Falla pruebas modernas r√°pidamente. Solo educativo."
    },
    "simpleCounter": {
      "name": "Contador Simple",
      "description": "El peor PRNG posible - solo incrementa en 1. Completamente predecible.",
      "recommended": "Aprender qu√© hace malo a un PRNG",
      "warning": "No es aleatorio en absoluto. Solo para comparaci√≥n educativa."
    },
    "references": {
      "pracrand": "PractRand",
      "mulberry32_gist": "Implementaci√≥n original",
      "splitmix_paper": "Art√≠culo SplitMix",
      "xorshift_paper": "Art√≠culo Xorshift RNGs",
      "xoshiro_paper": "Art√≠culo Scrambled Linear PRNGs",
      "lcg_wikipedia": "Wikipedia",
      "park_miller": "Art√≠culo Park-Miller"
    }
  },
  "dsl": {
    "error": {
      "unknownVariable": "Variable desconocida: {variable}",
      "tooManyOperations": "Demasiadas operaciones por paso",
      "outputVariableNotFound": "Variable de salida no encontrada: {variable}",
      "unknown": "Error desconocido"
    },
    "validate": {
      "nameRequired": "Se requiere el nombre del algoritmo",
      "stateRequired": "Se requiere al menos una variable de estado",
      "operationRequired": "Se requiere al menos una operaci√≥n",
      "undefinedVariable": "Operaci√≥n usa variable de estado indefinida: {variable}",
      "outputVariableNotFound": "Variable de salida no encontrada: {variable}"
    }
  },
  "operationDocs": {
    "title": "Referencia de Operaciones",
    "subtitle": "Aprende qu√© hace cada operaci√≥n",
    "introduction": "Estos son los bloques de construcci√≥n que usas para crear generadores de n√∫meros aleatorios. Cada operaci√≥n transforma n√∫meros de una manera espec√≠fica.",
    "whatAreBits": {
      "title": "¬øQu√© son los bits?",
      "content": "Las computadoras almacenan n√∫meros como secuencias de 0s y 1s llamados \"bits\". Por ejemplo, el n√∫mero 5 se almacena como 0101 en binario. Cada posici√≥n representa una potencia de 2: la m√°s a la derecha es 1, luego 2, luego 4, luego 8, y as√≠ sucesivamente. ¬°Entender los bits te ayuda a ver c√≥mo funcionan estas operaciones!"
    },
    "categories": {
      "arithmetic": "Operaciones Matem√°ticas",
      "arithmeticDesc": "Matem√°ticas b√°sicas como sumar y multiplicar n√∫meros",
      "bitwise": "Operaciones de Bits",
      "bitwiseDesc": "Operaciones que trabajan con bits individuales (0s y 1s)",
      "shift": "Operaciones de Desplazamiento",
      "shiftDesc": "Mueven bits a la izquierda o derecha dentro de un n√∫mero",
      "rotate": "Operaciones de Rotaci√≥n",
      "rotateDesc": "Mueven bits en c√≠rculo (no se pierde ning√∫n bit)"
    },
    "operations": {
      "add": {
        "name": "Suma",
        "brief": "Suma dos n√∫meros",
        "detailed": "¬°Igual que las matem√°ticas normales! Suma dos n√∫meros. Si el resultado es muy grande (m√°s de 4 mil millones), vuelve a empezar desde 0 - como el od√≥metro de un auto que da la vuelta.",
        "whyUseful": "La suma mezcla bien los n√∫meros porque el acarreo (como 9+1=10) causa que los cambios se propaguen por muchos d√≠gitos.",
        "example": "5 + 3 = 8",
        "exampleOverflow": "4.294.967.295 + 1 = 0 (¬°da la vuelta!)"
      },
      "sub": {
        "name": "Resta",
        "brief": "Resta un n√∫mero de otro",
        "detailed": "Resta normal. Si el resultado ser√≠a negativo, da la vuelta a un n√∫mero positivo grande.",
        "whyUseful": "Similar a la suma pero al rev√©s. Menos com√∫n en generadores aleatorios pero a√∫n √∫til.",
        "example": "5 - 3 = 2",
        "exampleOverflow": "0 - 1 = 4.294.967.295 (¬°da la vuelta!)"
      },
      "mul": {
        "name": "Multiplicaci√≥n",
        "brief": "Multiplica dos n√∫meros",
        "detailed": "Multiplica dos n√∫meros. Como la suma, si el resultado es muy grande, da la vuelta. La multiplicaci√≥n es muy poderosa para mezclar porque afecta muchos bits a la vez.",
        "whyUseful": "Multiplicar revuelve los bits muy efectivamente. Muchos de los mejores generadores aleatorios usan constantes de multiplicaci√≥n especiales.",
        "example": "3 √ó 5 = 15",
        "exampleOverflow": "Los n√∫meros grandes se ajustan para caber en 32 bits"
      },
      "mod": {
        "name": "M√≥dulo (Residuo)",
        "brief": "Obtiene el residuo despu√©s de dividir",
        "detailed": "Divide el primer n√∫mero por el segundo y te da el residuo. Como preguntar \"¬øqu√© sobra?\" Por ejemplo, 17 √∑ 5 = 3 residuo 2, entonces 17 mod 5 = 2.",
        "whyUseful": "Mantiene n√∫meros dentro de un rango espec√≠fico. Por ejemplo, n mod 100 siempre da un resultado entre 0 y 99.",
        "example": "17 % 5 = 2 (17 = 3√ó5 + 2, el residuo es 2)",
        "exampleOverflow": "10 % 3 = 1"
      },
      "xor": {
        "name": "XOR (O Exclusivo)",
        "brief": "Invierte bits donde las entradas difieren",
        "detailed": "Compara dos n√∫meros bit por bit. Si los bits son diferentes, el resultado es 1. Si son iguales, el resultado es 0. Pi√©nsalo como \"uno u otro, pero no ambos\".",
        "whyUseful": "¬°XOR es m√°gico para generadores aleatorios! Es reversible (A XOR B XOR B = A), mezcla bits sin perder informaci√≥n, y es muy r√°pido.",
        "example": "0101 XOR 0011 = 0110",
        "visualization": "Bit 1: ¬ø0‚â†0? No ‚Üí 0 | Bit 2: ¬ø1‚â†0? S√≠ ‚Üí 1 | Bit 3: ¬ø0‚â†1? S√≠ ‚Üí 1 | Bit 4: ¬ø1‚â†1? No ‚Üí 0"
      },
      "and": {
        "name": "AND (Y)",
        "brief": "Mantiene bits que son 1 en ambas entradas",
        "detailed": "Compara dos n√∫meros bit por bit. El resultado es 1 solo si AMBOS bits son 1. Pi√©nsalo como \"ambos deben estar de acuerdo\".",
        "whyUseful": "AND es genial para extraer bits espec√≠ficos de un n√∫mero (llamado \"enmascarar\"). Por ejemplo, n AND 255 extrae solo los √∫ltimos 8 bits.",
        "example": "0101 AND 0011 = 0001",
        "visualization": "Bit 1: 0 AND 0 = 0 | Bit 2: 1 AND 0 = 0 | Bit 3: 0 AND 1 = 0 | Bit 4: 1 AND 1 = 1"
      },
      "or": {
        "name": "OR (O)",
        "brief": "Activa bits que son 1 en cualquier entrada",
        "detailed": "Compara dos n√∫meros bit por bit. El resultado es 1 si CUALQUIER bit es 1. Pi√©nsalo como \"al menos uno dice s√≠\".",
        "whyUseful": "OR se usa para combinar bits o asegurar que ciertos bits est√©n activados. Menos com√∫n en generadores aleatorios que XOR.",
        "example": "0101 OR 0011 = 0111",
        "visualization": "Bit 1: 0 OR 0 = 0 | Bit 2: 1 OR 0 = 1 | Bit 3: 0 OR 1 = 1 | Bit 4: 1 OR 1 = 1"
      },
      "not": {
        "name": "NOT (Invertir Todos los Bits)",
        "brief": "Invierte cada bit",
        "detailed": "Invierte cada bit en el n√∫mero. Todos los 0s se vuelven 1s, y todos los 1s se vuelven 0s. Solo necesita una entrada.",
        "whyUseful": "NOT crea el \"opuesto\" de un n√∫mero. Rara vez se usa solo pero puede combinarse con otras operaciones.",
        "example": "NOT 0101 = 1010",
        "visualization": "Cada bit se invierte: 0‚Üí1 y 1‚Üí0"
      },
      "shl": {
        "name": "Desplazar a la Izquierda",
        "brief": "Mueve todos los bits a la izquierda",
        "detailed": "Mueve todos los bits a la izquierda un cierto n√∫mero de posiciones. Los espacios vac√≠os a la derecha se llenan con 0s. Los bits que salen por la izquierda se pierden.",
        "whyUseful": "Desplazar a la izquierda multiplica por potencias de 2. Desplazar 1 a la izquierda = multiplicar por 2. Tambi√©n es √∫til para mover bits a diferentes posiciones.",
        "example": "0001 << 2 = 0100 (desplazado 2 posiciones a la izquierda)",
        "visualization": "Original: 00000001 ‚Üí Despu√©s de << 2: 00000100"
      },
      "shr": {
        "name": "Desplazar a la Derecha (Con Signo)",
        "brief": "Mueve bits a la derecha, manteniendo el signo",
        "detailed": "Mueve todos los bits a la derecha. El bit m√°s a la izquierda (bit de signo) se copia para llenar espacios vac√≠os. Esto preserva si el n√∫mero es positivo o negativo.",
        "whyUseful": "Divide por potencias de 2 manteniendo el signo. Menos com√∫n en generadores aleatorios que el desplazamiento sin signo.",
        "example": "1000 >> 2 = 1110 (el bit de signo se propaga)",
        "visualization": "Para n√∫meros negativos, 1s llenan desde la izquierda"
      },
      "ushr": {
        "name": "Desplazar a la Derecha (Sin Signo)",
        "brief": "Mueve bits a la derecha, llenando con ceros",
        "detailed": "Mueve todos los bits a la derecha y siempre llena espacios vac√≠os con 0s. Trata el n√∫mero como positivo sin importar el bit m√°s a la izquierda.",
        "whyUseful": "La mayor√≠a de generadores aleatorios usan esto porque trabajan con patrones de bits, no n√∫meros con signo. ¬°Operaci√≥n muy com√∫n!",
        "example": "1000 >>> 2 = 0010 (ceros llenan desde la izquierda)",
        "visualization": "Original: 10000000 ‚Üí Despu√©s de >>> 2: 00100000"
      },
      "rotl": {
        "name": "Rotar a la Izquierda",
        "brief": "Rota bits a la izquierda (dan la vuelta)",
        "detailed": "Como desplazar a la izquierda, pero los bits que salen por la izquierda vuelven por la derecha. ¬°Nunca se pierde informaci√≥n - los bits solo se mueven en c√≠rculo!",
        "whyUseful": "La rotaci√≥n mezcla bits excelentemente sin perder ninguno. Muchos generadores aleatorios modernos usan rotaci√≥n porque es r√°pida y efectiva.",
        "example": "1001 rotl 1 = 0011 (el 1 de la izquierda pasa a la derecha)",
        "visualization": "Los bits se mueven en c√≠rculo: lado izquierdo ‚Üí lado derecho"
      },
      "rotr": {
        "name": "Rotar a la Derecha",
        "brief": "Rota bits a la derecha (dan la vuelta)",
        "detailed": "Como desplazar a la derecha, pero los bits que salen por la derecha vuelven por la izquierda. Igual que rotar a la izquierda pero en direcci√≥n opuesta.",
        "whyUseful": "Mismos beneficios que rotar a la izquierda. Combinado con XOR y suma, la rotaci√≥n crea una mezcla muy fuerte.",
        "example": "1001 rotr 1 = 1100 (el 1 de la derecha pasa a la izquierda)",
        "visualization": "Los bits se mueven en c√≠rculo: lado derecho ‚Üí lado izquierdo"
      }
    },
    "tips": {
      "title": "Consejos para Construir PRNGs",
      "tip1": "Combina diferentes tipos de operaciones (suma + XOR + desplazamiento) para mejor mezcla",
      "tip2": "Usa \"n√∫meros m√°gicos\" espec√≠ficos como constantes - han sido probados para funcionar bien",
      "tip3": "Aseg√∫rate de que cada bit se mezcle eventualmente - no dejes algunos bits sin cambiar",
      "tip4": "Prueba tu generador con las pesta√±as de Gr√°ficos y Pruebas para ver si es suficientemente aleatorio"
    },
    "tryIt": "¬°Pru√©balo!",
    "learnMore": "Aprender m√°s",
    "showDetails": "Mostrar detalles",
    "hideDetails": "Ocultar detalles"
  },
  "learn": {
    "title": "El Misterio de los N√∫meros M√°gicos",
    "subtitle": "Aprende c√≥mo las computadoras crean n√∫meros que parecen aleatorios",
    "resetProgress": "Reiniciar Progreso",
    "confirmReset": "¬øEst√°s seguro de que quieres reiniciar todo tu progreso de aprendizaje?",
    "completePrerequisites": "Completa el mundo anterior para desbloquear",
    "workshopUnlocked": {
      "title": "¬°Taller Desbloqueado!",
      "description": "Has ganado acceso al Taller completo. ¬°Experimenta libremente!"
    },
    "worlds": {
      "world1": {
        "title": "Mundo 1: Los N√∫meros que Recuerdan",
        "description": "Aprende sobre estado, memoria y variables",
        "badge": "Guardi√°n de N√∫meros"
      },
      "world2": {
        "title": "Mundo 2: Las Reglas Secretas",
        "description": "Aprende sobre multiplicaci√≥n, m√≥dulo y combinaci√≥n de operaciones",
        "badge": "Mezclador de Recetas"
      },
      "world2_5": {
        "title": "Mundo 2.5: Puente a los Bits",
        "description": "Introducci√≥n al pensamiento binario",
        "badge": "Explorador Binario"
      },
      "world3": {
        "title": "Mundo 3: La Danza de los Bits",
        "description": "Domina operaciones binarias como shift y XOR",
        "badge": "Maestro de Bits"
      },
      "world4": {
        "title": "Mundo 4: Constructores Maestros",
        "description": "Bifurca y modifica algoritmos PRNG reales",
        "badge": "Ingeniero de Aleatoriedad"
      },
      "world5": {
        "title": "Mundo 5: Laboratorio Avanzado",
        "description": "Algoritmos multi-estado y t√©cnicas avanzadas",
        "badge": "Investigador"
      }
    },
    "lessons": {
      "lesson1_1": {
        "title": "El N√∫mero Dormido",
        "objective": "Entender el concepto de variable/estado",
        "narrative": "Imagina que tienes una caja m√°gica. Dentro hay un n√∫mero. Ese n√∫mero est√° esperando... ¬øesperando qu√©?",
        "completion": "¬°Descubriste que los n√∫meros pueden guardarse!",
        "quiz": {
          "q1": {
            "question": "Si dos cajas empiezan con el mismo n√∫mero, ¬øsiempre producir√°n la misma secuencia?",
            "optionA": "No, cada caja crea sus propios n√∫meros aleatorios",
            "optionB": "S√≠, el mismo n√∫mero inicial siempre da los mismos resultados",
            "optionC": "Depende del clima",
            "correct": "¬°Exacto! Esto se llama DETERMINISMO - la misma entrada siempre da la misma salida.",
            "incorrect": "Pi√©nsalo: si la caja sigue las mismas reglas y empieza igual..."
          }
        }
      },
      "lesson1_2": {
        "title": "La Semilla M√°gica",
        "objective": "Entender que el estado inicial importa",
        "narrative": "¬øY si pudieras elegir con qu√© n√∫mero empieza la caja? Ese n√∫mero especial se llama SEMILLA.",
        "engagement": "¬°R√°pido! Piensa en tu n√∫mero favorito entre 1 y 100.",
        "completion": "¬°Aprendiste sobre las semillas!",
        "quiz": {
          "q1": {
            "question": "¬øQu√© es una semilla?",
            "optionA": "Una planta",
            "optionB": "El n√∫mero con el que empieza la caja",
            "optionC": "Un tipo de magia",
            "correct": "¬°Exacto! La semilla es el n√∫mero inicial.",
            "incorrect": "Piensa en qu√© n√∫mero ponemos primero en la caja."
          }
        }
      },
      "lesson1_3": {
        "title": "El Contador Aburrido",
        "objective": "Primera transformaci√≥n (suma simple)",
        "narrative": "Ahora tu caja puede hacer algo: ¬°CONTAR! Cada vez que presionas el bot√≥n, el n√∫mero crece.",
        "completion": "Esto es PREDECIBLE. ¬øSer√° as√≠ el azar verdadero?",
        "quiz": {
          "q1": {
            "question": "¬øPodr√≠a tu amigo predecir el siguiente n√∫mero de este contador?",
            "optionA": "S√≠, siempre es el n√∫mero actual m√°s 1",
            "optionB": "No, es imposible adivinarlo",
            "correct": "¬°Exacto! Un contador simple es completamente PREDECIBLE - ¬°terrible para la aleatoriedad!",
            "incorrect": "Observa el patr√≥n: 1, 2, 3, 4... ¬øpuedes adivinar qu√© sigue?"
          }
        }
      },
      "lesson1_4": {
        "title": "¬øD√≥nde est√° el Misterio?",
        "objective": "Identificar que la suma simple NO es aleatoria",
        "narrative": "Comparemos dos generadores de n√∫meros diferentes...",
        "completion": "Has aprendido que los n√∫meros pueden recordar y cambiar, pero solo sumar es muy aburrido. Necesitamos REGLAS M√ÅS INTERESANTES...",
        "quiz": {
          "q1": {
            "question": "¬øPor qu√© no podemos usar un contador simple para un juego de dados?",
            "optionA": "Los contadores son muy lentos",
            "optionB": "Los contadores solo llegan hasta 6",
            "optionC": "Los jugadores podr√≠an predecir f√°cilmente el pr√≥ximo tiro",
            "correct": "¬°Correcto! La predictibilidad es enemiga de los juegos justos. ¬°Necesitamos n√∫meros impredecibles!",
            "incorrect": "Piensa qu√© pasar√≠a si tu oponente conociera el patr√≥n..."
          }
        }
      },
      "lesson2_1": {
        "title": "Multiplicaci√≥n Explosiva",
        "objective": "Ver c√≥mo la multiplicaci√≥n crea cambios dram√°ticos",
        "narrative": "Sumar es como caminar. Multiplicar es como... ¬°SALTAR!",
        "completion": "¬°Descubriste que la multiplicaci√≥n hace crecer los n√∫meros mucho m√°s r√°pido!",
        "quiz": {
          "q1": {
            "question": "Si multiplicas por 1 en cada paso, ¬øqu√© pasa con la aleatoriedad?",
            "optionA": "Aleatoriedad perfecta",
            "optionB": "Aleatoriedad m√°s lenta",
            "optionC": "¬°Ning√∫n cambio - terrible para la aleatoriedad!",
            "correct": "¬°Correcto! Multiplicar por 1 no hace nada - el n√∫mero nunca cambia. ¬°In√∫til!",
            "incorrect": "Piensa: ¬øqu√© es cualquier n√∫mero por 1?"
          }
        }
      },
      "lesson2_2": {
        "title": "El Problema del N√∫mero Gigante",
        "objective": "Entender el desbordamiento y los l√≠mites de memoria",
        "narrative": "¬øQu√© pasa si multiplicamos tantas veces que el n√∫mero ya no cabe?",
        "completion": "Las computadoras tienen cajas de tama√±o fijo. ¬°Cuando se desbordan, dan la vuelta como un reloj!",
        "quiz": {
          "q1": {
            "question": "¬°El n√∫mero se desbord√≥ y dio la vuelta! ¬øEs esto un error o una caracter√≠stica para PRNGs?",
            "optionA": "Un error - deber√≠amos arreglarlo",
            "optionB": "¬°Una caracter√≠stica - ayuda a crear patrones impredecibles!",
            "correct": "¬°Exacto! El desbordamiento es √öTIL porque mezcla el n√∫mero de formas inesperadas.",
            "incorrect": "Piensa: ¬øel desbordamiento hace los n√∫meros m√°s o menos predecibles?"
          }
        }
      },
      "lesson2_3": {
        "title": "El Cortador (M√≥dulo)",
        "objective": "Entender el operador m√≥dulo",
        "narrative": "¬øY si queremos un n√∫mero que nunca pase de 10? Usamos EL CORTADOR.",
        "completion": "¬°El operador m√≥dulo recorta los n√∫meros a su tama√±o!",
        "quiz": {
          "q1": {
            "question": "¬øPor qu√© los PRNGs usan n√∫meros primos (como 7, 13, 31) en vez de n√∫meros redondos (como 10, 100)?",
            "optionA": "Los n√∫meros primos son m√°s bonitos",
            "optionB": "Los primos crean patrones menos obvios y ciclos m√°s largos",
            "optionC": "Los n√∫meros redondos son muy grandes",
            "correct": "¬°Correcto! Los primos ayudan a evitar patrones repetitivos que har√≠an la salida predecible.",
            "incorrect": "Piensa en qu√© hace que una secuencia se sienta 'aleatoria' vs 'con patr√≥n'..."
          }
        }
      },
      "lesson2_4": {
        "title": "Mezclando Recetas",
        "objective": "Combinar operaciones (multiplicar + sumar)",
        "narrative": "¬øQu√© pasa si usamos DOS reglas al mismo tiempo?",
        "completion": "¬°Combinar operaciones crea patrones m√°s interesantes!",
        "quiz": {
          "q1": {
            "question": "DEPURAR: Esta receta produce 0, 0, 0, 0... ¬øQu√© est√° mal?\n\nestado = estado √ó 2\nestado = estado √ó 0",
            "optionA": "La multiplicaci√≥n por 2 est√° mal",
            "optionB": "¬°Multiplicar por 0 destruye todo!",
            "optionC": "Necesitamos agregar m√°s pasos",
            "correct": "¬°Exacto! Cualquier cosa por 0 es igual a 0. ¬°Una mala operaci√≥n puede arruinar todo!",
            "incorrect": "¬øQu√© pasa cuando multiplicas CUALQUIER n√∫mero por 0?",
            "hint1": "Intenta calcular: 5 √ó 2 √ó 0 = ?"
          }
        }
      },
      "lesson2_5": {
        "title": "LCG: Tu Primer Generador Real",
        "objective": "Explorar un generador lineal real mediante fork",
        "narrative": "Los cient√≠ficos descubrieron una receta especial llamada LCG. ¬°Modifiquemos uno real!",
        "completion": "¬°Has explorado un algoritmo PRNG real!",
        "quiz": {
          "q1": {
            "question": "Intenta cambiar el multiplicador del LCG de 1664525 a solo 2. ¬øQu√© pasa con la calidad de salida?",
            "optionA": "La salida se ve igual - cualquier multiplicador funciona bien",
            "optionB": "La salida empeora - el n√∫mero original fue elegido cuidadosamente por matem√°ticos",
            "correct": "¬°Exacto! Esas constantes espec√≠ficas (como 1664525) fueron probadas extensivamente. ¬°Los n√∫meros que parecen aleatorios suelen funcionar mejor que los simples!",
            "incorrect": "Mira el histograma y el gr√°fico de correlaci√≥n despu√©s de cambiar el multiplicador. ¬øLos patrones parecen aleatorios?"
          }
        }
      },
      "lesson2_5_1": {
        "title": "El Juego de Adivinar",
        "objective": "Descubrir c√≥mo las preguntas s√≠/no encuentran n√∫meros r√°pido",
        "narrative": "¬øSab√≠as que las computadoras solo entienden dos cosas? S√ç y NO. ¬°Eso es todo! Juguemos un juego de adivinanzas - t√∫ eliges un n√∫mero y yo lo encontrar√© usando solo preguntas de s√≠/no. ¬°Mira qu√© r√°pido lo reducimos!",
        "completion": "¬°Con solo preguntas de s√≠/no puedes encontrar cualquier n√∫mero! Esta es la base del pensamiento binario.",
        "quiz": {
          "q1": {
            "question": "Para encontrar un n√∫mero del 1 al 16, ¬øqu√© estrategia es m√°s r√°pida?",
            "optionA": "Preguntar '¬øEs el 1? ¬øEs el 2? ¬øEs el 3?...' uno por uno (hasta 16 preguntas)",
            "optionB": "Preguntar '¬øEs mayor que 8?' y seguir dividiendo a la mitad (solo 4 preguntas)",
            "optionC": "Adivinar al azar",
            "correct": "¬°Exacto! Dividir a la mitad es mucho m√°s r√°pido: 16‚Üí8‚Üí4‚Üí2‚Üí1 en solo 4 pasos!",
            "incorrect": "Pi√©nsalo: verificar uno por uno podr√≠a tomar 16 intentos. ¬øCu√°ntas divisiones a la mitad para ir de 16 a 1?"
          }
        }
      },
      "lesson2_5_2": {
        "title": "N√∫meros con Interruptores",
        "objective": "Introducir representaci√≥n binaria de 4 bits",
        "narrative": "Imagina 4 interruptores. Cada uno puede estar ENCENDIDO o APAGADO. ¬°Juntos forman un n√∫mero!",
        "completion": "¬°Puedes representar cualquier n√∫mero del 0 al 15 con solo 4 interruptores!",
        "quiz": {
          "q1": {
            "question": "Si cambias solo UN bit, ¬øcu√°nto puede cambiar el n√∫mero?",
            "optionA": "¬°Mucho! El bit de la izquierda cambia el n√∫mero en 8",
            "optionB": "Siempre cambia exactamente en 1",
            "correct": "¬°Correcto! La posici√≥n importa - cambiar el bit izquierdo cambia en 8, el derecho en 1!",
            "incorrect": "Intenta cambiar diferentes bits y observa qu√© pasa con el n√∫mero."
          }
        }
      },
      "lesson2_5_3": {
        "title": "M√°s Interruptores, N√∫meros M√°s Grandes",
        "objective": "Expandir a 8 bits, vista previa de 32 bits",
        "narrative": "¬øY si tuvi√©ramos M√ÅS interruptores? ¬°Podr√≠amos hacer n√∫meros M√ÅS GRANDES!",
        "completion": "Ahora entiendes c√≥mo las computadoras ven los n√∫meros. ¬°Es hora de aprender a BAILAR con los bits!",
        "quiz": {
          "q1": {
            "question": "Con 32 bits, las computadoras pueden almacenar m√°s de 4 MIL MILLONES de n√∫meros diferentes. ¬øEs suficiente para un juego?",
            "optionA": "No, los juegos necesitan m√°s n√∫meros",
            "optionB": "¬°S√≠! 4 mil millones de estados significa que los patrones no se repetir√°n por mucho tiempo",
            "correct": "¬°Exacto! 4 mil millones de posibilidades significa que un jugador nunca ver√≠a el patr√≥n repetirse.",
            "incorrect": "Piensa cu√°nto tiempo tomar√≠a contar hasta 4 mil millones..."
          }
        }
      },
      "lesson3_1": {
        "title": "El Desplazamiento (Moviendo Bits)",
        "objective": "Entender el desplazamiento de bits",
        "narrative": "¬øQu√© pasa si EMPUJAMOS todos los interruptores hacia la izquierda?",
        "completion": "¬°Desplazar a la izquierda es como multiplicar por 2, pero m√°s r√°pido para las computadoras!",
        "quiz": {
          "q1": {
            "question": "¬øPor qu√© el desplazamiento de bits podr√≠a ser MEJOR que la multiplicaci√≥n para un PRNG?",
            "optionA": "El desplazamiento es m√°s lento pero m√°s preciso",
            "optionB": "El desplazamiento es extremadamente r√°pido - las computadoras lo hacen en un ciclo de reloj",
            "optionC": "El desplazamiento hace patrones m√°s bonitos",
            "correct": "¬°Exacto! La velocidad importa para los PRNGs - ¬°pueden ser llamados millones de veces!",
            "incorrect": "Piensa en qu√© hace a un buen PRNG: calidad Y velocidad."
          }
        }
      },
      "lesson3_2": {
        "title": "XOR: El Detector de Diferencias",
        "objective": "Entender la operaci√≥n XOR",
        "narrative": "XOR es una regla especial: compara dos bits y verifica si son DIFERENTES.",
        "completion": "¬°XOR tiene una propiedad m√°gica: hacerlo dos veces te devuelve al original!",
        "quiz": {
          "q1": {
            "question": "XOR dos veces con el mismo n√∫mero devuelve el original. ¬øC√≥mo podr√≠a ser √∫til esto?",
            "optionA": "No es √∫til en absoluto",
            "optionB": "Puedes usarlo para 'ocultar' y 'revelar' datos - ¬°como encriptaci√≥n simple!",
            "correct": "¬°Correcto! XOR se usa en encriptaci√≥n, checksums y mezcla de bits en PRNGs.",
            "incorrect": "Piensa: si A XOR B XOR B = A, ¬øqu√© puedes hacer con esa propiedad?"
          }
        }
      },
      "lesson3_3": {
        "title": "La Mezcla Perfecta",
        "objective": "Combinar shift y XOR",
        "narrative": "Los magos de los n√∫meros descubrieron algo: si desplazas Y mezclas con XOR, ¬°los n√∫meros BAILAN!",
        "completion": "¬°Un peque√±o cambio en la entrada crea un GRAN cambio en la salida!",
        "quiz": {
          "q1": {
            "question": "¬øPor qu√© combinamos shift y XOR?",
            "optionA": "Hace los n√∫meros m√°s peque√±os",
            "optionB": "Crea cambios m√°s impredecibles",
            "correct": "¬°Exacto! La combinaci√≥n mezcla los bits efectivamente.",
            "incorrect": "Piensa c√≥mo cada operaci√≥n afecta el patr√≥n."
          }
        }
      },
      "lesson3_4": {
        "title": "Xorshift: Tu Segundo Generador Real",
        "objective": "Explorar Xorshift mediante fork",
        "narrative": "Ahora trabajemos con un generador profesional que usa lo que aprendiste.",
        "completion": "¬°Has dominado las operaciones m√°s poderosas. Es hora de construir generadores PROFESIONALES!",
        "quiz": {
          "q1": {
            "question": "DEPURAR: Este Xorshift produce l√≠neas diagonales visibles en el gr√°fico de correlaci√≥n. ¬øQu√© valor de desplazamiento probablemente est√° mal?",
            "optionA": "El primer desplazamiento (muy peque√±o)",
            "optionB": "El desplazamiento del medio - probablemente no est√° mezclando los bits suficiente",
            "optionC": "El √∫ltimo desplazamiento (muy grande)",
            "correct": "¬°Correcto! La mala mezcla a menudo viene de operaciones del medio que no dispersan bien los bits.",
            "incorrect": "Las l√≠neas diagonales significan que los n√∫meros consecutivos est√°n muy relacionados. ¬øQu√© lo arregla?",
            "hint1": "Los problemas de correlaci√≥n usualmente significan que los bits no se est√°n mezclando bien."
          }
        }
      },
      "lesson4_1": {
        "title": "Mulberry32: La M√°quina Industrial",
        "objective": "Explorar un algoritmo de producci√≥n real mediante fork",
        "narrative": "Este es Mulberry32, un generador usado en aplicaciones profesionales. ¬°Explor√©moslo!",
        "completion": "¬°Has analizado un PRNG de grado profesional!",
        "quiz": {
          "q1": {
            "question": "¬øCu√°ntos tipos de operaciones usa Mulberry32?",
            "optionA": "Solo una (suma)",
            "optionB": "Dos (suma y multiplicaci√≥n)",
            "optionC": "Cuatro (suma, xor, shift, multiplicaci√≥n)",
            "correct": "¬°Correcto! Combina m√∫ltiples operaciones para mejor mezcla.",
            "incorrect": "Mira el algoritmo - usa suma, xor, shift y multiplicaci√≥n."
          }
        }
      },
      "lesson4_2": {
        "title": "El Laboratorio de Calidad",
        "objective": "Usar el conjunto completo de pruebas",
        "narrative": "Los cient√≠ficos usan pruebas especiales para verificar si los n√∫meros parecen verdaderamente aleatorios. ¬°Us√©moslas!",
        "completion": "¬°Ahora sabes c√≥mo evaluar cualquier generador cient√≠ficamente!",
        "quiz": {
          "q1": {
            "question": "¬øQu√© algoritmo pasa todas las pruebas de calidad?",
            "optionA": "Contador simple",
            "optionB": "Mulberry32",
            "correct": "¬°S√≠! Mulberry32 pasa todas las pruebas mientras el contador falla en todas.",
            "incorrect": "Revisa los resultados de las pruebas para cada algoritmo."
          }
        }
      },
      "lesson4_3": {
        "title": "El Desaf√≠o del Dise√±ador",
        "objective": "Crear tu propio generador",
        "narrative": "¬°Ahora es TU turno de dise√±ar un generador de n√∫meros!",
        "completion": "¬°Has creado tu propio algoritmo PRNG!"
      },
      "lesson4_4": {
        "title": "La Galer√≠a de Generadores",
        "objective": "Comparar todos los algoritmos aprendidos",
        "narrative": "Veamos c√≥mo se comparan todos los generadores que hemos aprendido.",
        "completion": "¬°Felicitaciones! Entiendes c√≥mo las computadoras crean n√∫meros que parecen aleatorios. ¬°Taller desbloqueado!",
        "quiz": {
          "q1": {
            "question": "¬øQu√© hace un buen PRNG?",
            "optionA": "Usar operaciones simples",
            "optionB": "Pasar pruebas de calidad y ser eficiente",
            "correct": "¬°Exacto! Un buen PRNG equilibra calidad con rendimiento.",
            "incorrect": "Piensa tanto en la calidad de aleatoriedad como en la velocidad."
          }
        }
      },
      "lesson5_1": {
        "title": "Algoritmos Multi-Estado",
        "objective": "Entender algoritmos con m√∫ltiples variables de estado",
        "narrative": "¬øY si us√°ramos M√öLTIPLES cajas en vez de una?",
        "completion": "¬°M√∫ltiples variables de estado hacen los algoritmos m√°s dif√≠ciles de predecir!",
        "quiz": {
          "q1": {
            "question": "¬øPor qu√© los algoritmos avanzados usan m√∫ltiples variables de estado?",
            "optionA": "Es m√°s simple",
            "optionB": "M√°s dif√≠cil de predecir, per√≠odo m√°s largo",
            "optionC": "Es m√°s r√°pido",
            "correct": "¬°Correcto! M√∫ltiples variables interact√∫an de formas complejas.",
            "incorrect": "Piensa c√≥mo 4 variables pueden interactuar vs solo 1."
          }
        }
      },
      "lesson5_2": {
        "title": "xoshiro128**: El Moderno",
        "objective": "Explorar algoritmos modernos",
        "narrative": "Este algoritmo fue creado en 2018 por Blackman y Vigna. ¬°Es de √∫ltima generaci√≥n!",
        "completion": "¬°Has explorado uno de los algoritmos PRNG m√°s modernos!",
        "quiz": {
          "q1": {
            "question": "¬øQu√© hace especial a xoshiro128**?",
            "optionA": "128 bits de estado y excelente calidad",
            "optionB": "Es muy lento",
            "correct": "¬°S√≠! Usa 128 bits y pasa pruebas rigurosas.",
            "incorrect": "Piensa en su tama√±o de estado y calidad."
          }
        }
      },
      "lesson5_3": {
        "title": "Interpretaci√≥n Avanzada de Pruebas",
        "objective": "Entender profundamente los resultados de las pruebas de calidad",
        "narrative": "Aprendamos qu√© mide realmente cada prueba y qu√© significan los fallos.",
        "completion": "¬°Ahora puedes interpretar resultados de pruebas como un verdadero cript√≥grafo!",
        "quiz": {
          "q1": {
            "question": "¬øQu√© mide la prueba de sesgo de bits?",
            "optionA": "Qu√© tan r√°pido es el algoritmo",
            "optionB": "Si cada bit tiene 50% de probabilidad de estar ENCENDIDO",
            "optionC": "El valor promedio de salida",
            "correct": "¬°Correcto! Cada bit debe ser igualmente probable de ser 0 o 1.",
            "incorrect": "Piensa qu√© significa 'sesgo' para bits individuales."
          }
        }
      },
      "lesson5_4": {
        "title": "Tu Proyecto Final",
        "objective": "Crear un generador original y documentarlo",
        "narrative": "Es hora de mostrar todo lo que has aprendido. ¬°Crea tu obra maestra!",
        "completion": "üèÜ ¬°Felicitaciones! ¬°Has completado el curso avanzado y creado tu propio algoritmo documentado!"
      }
    },
    "microTeaching": {
      "counting": {
        "concept": "Contar",
        "content": "Cuenta las manzanas: üçéüçéüçéüçéüçé = ?",
        "insight": "¬°Sumar significa contar hacia arriba!"
      },
      "multiplication": {
        "concept": "Multiplicaci√≥n",
        "content": "Antes de saltar, ¬°aprendamos qu√© significa multiplicar!",
        "insight": "¬°La multiplicaci√≥n es suma repetida, pero M√ÅS R√ÅPIDA!"
      },
      "remainder": {
        "concept": "Residuos",
        "content": "¬°Aprendamos sobre los sobrantes! 7 dulces para 3 amigos...",
        "insight": "¬°El residuo es lo que queda despu√©s de dividir equitativamente!"
      },
      "xor": {
        "concept": "XOR (O Exclusivo)",
        "content": "XOR compara dos bits: si son DIFERENTES, el resultado es 1. Si son IGUALES, el resultado es 0.",
        "insight": "¬øDiferentes? ENCENDIDO. ¬øIguales? APAGADO. ¬°Es como un detector de diferencias!"
      },
      "shift": {
        "concept": "Desplazamiento de Bits",
        "content": "Mover todos los bits a la izquierda o derecha, como deslizar fichas en un tablero.",
        "insight": "¬°Desplazar a la izquierda = multiplicar por 2. Desplazar a la derecha = dividir por 2!"
      },
      "binary": {
        "concept": "N√∫meros Binarios",
        "content": "Las computadoras usan solo ENCENDIDO y APAGADO (1 y 0) para representar todos los n√∫meros.",
        "insight": "¬°Con solo 8 interruptores puedes representar 256 n√∫meros diferentes!"
      }
    },
    "microTeachingLabel": "Mini Lecci√≥n",
    "badges": {
      "collection": "Tus Insignias",
      "earnedOn": "Obtenido el {date}",
      "numberKeeper": {
        "name": "Guardi√°n de N√∫meros",
        "alt": "Insignia de Guardi√°n de N√∫meros - Una medalla p√∫rpura con una caja que contiene el n√∫mero 42",
        "description": "¬°Descubriste que los n√∫meros pueden guardarse!"
      },
      "recipeMixer": {
        "name": "Mezclador de Recetas",
        "alt": "Insignia de Mezclador de Recetas - Una medalla naranja con un taz√≥n de mezcla y s√≠mbolos matem√°ticos",
        "description": "¬°Aprendiste a combinar operaciones para crear recetas de n√∫meros!"
      },
      "binaryExplorer": {
        "name": "Explorador Binario",
        "alt": "Insignia de Explorador Binario - Una medalla verde con d√≠gitos binarios e interruptores",
        "description": "¬°Entiendes c√≥mo las computadoras ven los n√∫meros como bits!"
      },
      "bitMaster": {
        "name": "Maestro de Bits",
        "alt": "Insignia de Maestro de Bits - Una medalla azul con c√≠rculos XOR y flechas de desplazamiento",
        "description": "¬°Dominaste el baile de bits con XOR y desplazamientos!"
      },
      "randomnessEngineer": {
        "name": "Ingeniero de Aleatoriedad",
        "alt": "Insignia de Ingeniero de Aleatoriedad - Una medalla √°mbar con un engranaje y llave",
        "description": "¬°Puedes construir y probar generadores de n√∫meros aleatorios profesionales!"
      },
      "researcher": {
        "name": "Investigador",
        "alt": "Insignia de Investigador - Una medalla dorada con lupa, gr√°fico y documento",
        "description": "¬°Dominaste algoritmos avanzados y completaste el curso completo!"
      }
    },
    "operationTrace": {
      "title": "Traza Paso a Paso"
    },
    "comparison": {
      "title": "Comparaci√≥n de Algoritmos"
    },
    "worldLesson": "Mundo {world} ¬∑ Lecci√≥n {lesson}",
    "continue": "Continuar",
    "previous": "Anterior",
    "finish": "Finalizar",
    "checkAnswer": "Verificar Respuesta",
    "nextQuestion": "Siguiente Pregunta",
    "enterAnswer": "Ingresa tu respuesta",
    "activities": {
      "wakeUp": "Despertar el n√∫mero",
      "enterNumber": "Ingresa un n√∫mero...",
      "yourNumber": "¬°Ese es TU n√∫mero especial: {number}!",
      "seed": "Semilla",
      "currentNumber": "N√∫mero actual",
      "nextNumber": "Siguiente n√∫mero",
      "reset": "Reiniciar",
      "counter": "Contador Simple",
      "counterDesc": "Solo suma 1 cada vez (¬°predecible!)",
      "professional": "Generador Profesional",
      "algorithmDesc": "Usa mezcla matem√°tica",
      "stepBoth": "Avanzar Ambos",
      "comparisonIntro": "Compara un contador simple con un algoritmo PRNG real. ¬°Nota la diferencia de patr√≥n!",
      "comparisonHint": "El contador muestra una l√≠nea diagonal (predecible). Los buenos PRNGs muestran puntos dispersos (impredecibles).",
      "overflowExplanation": "¬°Cuando multiplicamos m√°s all√° de {max}, el n√∫mero da la vuelta!",
      "multiply": "Multiplicar √ó{n}",
      "forkExplore": "Explora este algoritmo modificando sus constantes y observando los resultados.",
      "forkExploreAlgorithm": "Algoritmo:",
      "forkExploreHint": "Intenta cambiar las constantes. ¬°Observa c√≥mo cambia la calidad!",
      "forkExploreHintLcg": "Intenta cambiar el multiplicador y la constante de suma. ¬°Diferentes valores crean diferentes patrones!",
      "forkExploreHintXorshift": "Intenta cambiar las cantidades de desplazamiento (13, 17, 5). ¬°Observa c√≥mo la mezcla de bits afecta la aleatoriedad!",
      "forkExploreHintMulberry": "Experimenta con la constante m√°gica y observa c√≥mo cambia la calidad de salida.",
      "forkExploreHintMultiState": "Este algoritmo tiene m√∫ltiples variables de estado. ¬°Observa c√≥mo interact√∫an juntas!",
      "algorithmExplorer": {
        "state": "Estado Actual",
        "output": "Salida",
        "step": "Paso",
        "timeSeries": "Salida en el Tiempo",
        "correlation": "Gr√°fico de Correlaci√≥n",
        "steps": "{count} pasos generados"
      },
      "qualityLab": {
        "title": "Laboratorio de Calidad",
        "intro": "Ejecuta pruebas en diferentes algoritmos para ver cu√°les producen mejores n√∫meros aleatorios.",
        "runTests": "Ejecutar Pruebas",
        "comparing": "Comparando algoritmos...",
        "testMean": "Prueba de Media",
        "testVariance": "Prueba de Varianza",
        "testChiSquare": "Prueba Chi-Cuadrado",
        "passed": "APROBADO",
        "failed": "FALLIDO"
      },
      "designerChallenge": {
        "title": "Desaf√≠o de Dise√±o",
        "intro": "¬°Crea tu propio generador que pase todas las pruebas!",
        "challenge1": "Pasar la prueba del histograma",
        "challenge2": "Usar 5 o menos operaciones",
        "challenge3": "Pasar todas las pruebas de calidad",
        "completed": "¬°Desaf√≠o completado!",
        "tryAgain": "¬°Sigue intentando!"
      },
      "testInterpretation": {
        "title": "Entendiendo los Resultados",
        "intro": "Aprende qu√© mide cada prueba y qu√© significan los fallos.",
        "meanExplain": "La prueba de Media verifica si tus n√∫meros promedian 0.5 (el medio del rango 0-1).",
        "varianceExplain": "La Varianza mide qu√© tan dispersos est√°n tus n√∫meros.",
        "chiSquareExplain": "Chi-Cuadrado verifica si los n√∫meros est√°n distribuidos uniformemente en todos los rangos."
      },
      "finalProject": {
        "title": "Tu Proyecto Final",
        "intro": "¬°Dise√±a y documenta tu propio algoritmo PRNG!",
        "buildAlgorithm": "Construye tu algoritmo eligiendo operaciones:",
        "qualityScore": "Puntuaci√≥n de Calidad",
        "steps": "{count} pasos generados"
      },
      "binaryGame": {
        "thinkOfNumber": "Piensa en un n√∫mero entre 1 y 16. ¬°Lo encontrar√© con solo preguntas de s√≠/no!",
        "range": "Elige cualquier n√∫mero del {min} al {max}",
        "question": "¬øTu n√∫mero es mayor que {mid}?",
        "yes": "S√≠",
        "no": "No",
        "found": "¬°Tu n√∫mero es {number}!",
        "guessCount": "¬°Lo encontr√© en solo {count} preguntas!",
        "playAgain": "Jugar de Nuevo",
        "history": "Preguntas realizadas:"
      },
      "shiftDemo": {
        "current": "Valor Actual",
        "shiftBy": "Desplazar por:",
        "shiftLeft": "Desplazar Izquierda",
        "shiftRight": "Desplazar Derecha",
        "history": "Historial de Desplazamientos"
      },
      "xorExperiment": {
        "intro": "Prueba diferentes valores para A y B. ¬°Observa c√≥mo XOR compara cada bit!",
        "result": "A XOR B =",
        "hint": "Nota: cuando los bits son DIFERENTES ‚Üí 1, cuando son IGUALES ‚Üí 0"
      },
      "shiftXor": {
        "current": "Estado Actual",
        "formula": "Cada paso: estado ^= estado << 7; estado ^= estado >>> 5",
        "step": "Paso"
      }
    },
    "sandbox": {
      "title": "Tu M√°quina de N√∫meros",
      "step": "Paso {count}",
      "state": "Valor actual",
      "nextStep": "Siguiente Paso",
      "reset": "Reiniciar",
      "allowedOperations": "Operaciones disponibles"
    },
    "modulo": {
      "title": "La Rueda del M√≥dulo (mod {mod})",
      "value": "Valor",
      "reset": "Reiniciar",
      "enterValue": "Ingresa un n√∫mero",
      "set": "Establecer"
    },
    "multiplication": {
      "title": "La Tabla de Multiplicar",
      "explanation": "{rows} filas de {cols} = {result} en total",
      "clear": "Limpiar"
    },
    "bits": {
      "title": "Toggle de {count} Bits",
      "decimal": "Decimal",
      "binary": "Binario",
      "hex": "Hex",
      "clear": "Limpiar",
      "max": "M√°x",
      "range": "Rango: {min} a {max}"
    },
    "calculator": {
      "title": "Calculadora por Pasos",
      "currentValue": "Valor Actual",
      "operand": "N√∫mero",
      "apply": "Aplicar",
      "history": "Pasos",
      "undo": "Deshacer",
      "reset": "Reiniciar"
    },
    "candy": {
      "title": "Repartir los Dulces",
      "candies": "Dulces",
      "friends": "Amigos",
      "leftover": "¬°Sobran!",
      "remainder": "(resto {r})",
      "insight": "El resto es lo que sobra cuando no puedes dividir exactamente. ¬°Esto es exactamente lo que calcula 'mod' (m√≥dulo)!"
    },
    "counting": {
      "title": "Contando Paso a Paso",
      "insight": "Sumar 1 cada vez es la transformaci√≥n m√°s simple. Es predecible - ¬°por eso NO es aleatorio!"
    }
  }
}
