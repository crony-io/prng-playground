{
  "app": {
    "title": "PRNG School",
    "description": "Aprende c√≥mo los algoritmos PRNG transforman estado, semilla y entrop√≠a ‚Äî interactivamente.",
    "welcome": {
      "badge": "Bienvenido",
      "title": "Generador de n√∫meros pseudoaleatorios",
      "description": "Aprende c√≥mo los algoritmos PRNG transforman estado, semilla y entrop√≠a ‚Äî interactivamente."
    }
  },
  "common": {
    "generate": "Generar",
    "copy": "Copiar",
    "save": "Guardar",
    "cancel": "Cancelar",
    "close": "Cerrar",
    "delete": "Eliminar",
    "loading": "Cargando...",
    "success": "¬°√âxito!",
    "error": "Error",
    "warning": "Advertencia",
    "unknown": "Desconocido",
    "unknownError": "Error desconocido",
    "example": "Ejemplo"
  },
  "prngRunner": {
    "errors": {
      "algorithmNotFound": "Algoritmo \"{id}\" no encontrado",
      "failedToInitialize": "No se pudo inicializar",
      "invalidValue": "El generador produjo un valor inv√°lido (NaN o infinito)",
      "valueOutOfRange": "Valor fuera de rango [0, 1): {value}",
      "stepFailed": "Fall√≥ el paso"
    }
  },
  "theme": {
    "selector": {
      "aria_label": "Cambiar tema a {theme}"
    },
    "options": {
      "light": "Claro",
      "dark": "Oscuro",
      "system": "Sistema"
    }
  },
  "language": {
    "selector": {
      "aria_label": "Cambiar idioma a {language}"
    }
  },
  "navigation": {
    "home": "Inicio",
    "learn": "Aprender",
    "about": "Acerca de",
    "workshop": "Taller",
    "toggleMenu": "Alternar men√∫"
  },
  "workshop": {
    "title": "Taller de Algoritmos",
    "description": "Crea, edita y experimenta con tus propios algoritmos PRNG",
    "showHelp": "Ayuda",
    "hideHelp": "Ocultar Ayuda",
    "createNew": "Nuevo Algoritmo",
    "algorithms": "Tus Algoritmos",
    "noAlgorithms": "A√∫n no hay algoritmos. ¬°Crea el primero!",
    "untitled": "Sin t√≠tulo",
    "forkedFrom": "Derivado de",
    "fork": "Derivar",
    "custom": "Personalizado",
    "editor": "Editor",
    "name": "Nombre",
    "namePlaceholder": "Mi PRNG",
    "algorithmDescription": "Descripci√≥n",
    "descriptionPlaceholder": "Describe tu algoritmo...",
    "stateVariables": "Variables de Estado",
    "addVariable": "Agregar Variable",
    "outputVariable": "Variable de Salida",
    "operations": "Operaciones",
    "addOperation": "Agregar Operaci√≥n",
    "customConst": "Personalizado...",
    "preview": "Vista Previa",
    "forkBuiltin": "Derivar de Predefinido",
    "testSeed": "Semilla de Prueba",
    "runSize": "Tama√±o de Ejecuci√≥n",
    "autoDuration": "Auto (s)",
    "moveUp": "Mover arriba",
    "moveDown": "Mover abajo",
    "editorModes": {
      "visual": "Visual",
      "code": "C√≥digo"
    },
    "codeEditor": {
      "label": "C√≥digo de Operaciones",
      "placeholder": "s = s + 1\ns = s ^ 0x9e3779b9\ns = s >>> 13\ns = rotl(s, 5)",
      "format": "Formatear",
      "revert": "Revertir",
      "apply": "Aplicar",
      "newVariables": "Se crear√°n nuevas variables (valor inicial 0): {vars}",
      "errorAt": "L√≠nea {line}, Col {column}: {message}",
      "toast": {
        "applied": "Aplicado",
        "fixErrorsBeforeApply": "Corrige los errores antes de aplicar",
        "fixErrorsBeforeFormat": "Corrige los errores antes de formatear",
        "needOneOperation": "Agrega al menos una operaci√≥n"
      },
      "errors": {
        "invalid_statement": "Sentencia inv√°lida (se espera: objetivo = expresi√≥n)",
        "invalid_target": "Objetivo inv√°lido: {target}",
        "invalid_expression": "Expresi√≥n inv√°lida",
        "invalid_operand": "Operando inv√°lido: {token}",
        "invalid_number": "N√∫mero inv√°lido: {token}",
        "amount_must_be_number": "La cantidad de desplazamiento/rotaci√≥n debe ser un n√∫mero (0-31): {token}",
        "amount_out_of_range": "Cantidad de desplazamiento/rotaci√≥n fuera de rango (0-31): {amount}",
        "unsupported_operator": "Operador no soportado: {operator}",
        "unsupported_function": "Funci√≥n no soportada",
        "unknown": "Error desconocido"
      }
    },
    "previewTabs": {
      "state": "Estado",
      "charts": "Gr√°ficos",
      "tests": "Pruebas"
    },
    "previewPanel": {
      "stateEmpty": "Haz clic en {action} para generar muestras",
      "chartsEmpty": "Ejecuta el algoritmo para ver visualizaciones"
    },
    "autoTests": {
      "title": "Pruebas de Calidad",
      "runTests": "Ejecutar Pruebas",
      "mean": "Media",
      "variance": "Varianza",
      "expected": "esperado",
      "chiSquare": "Chi-Cuadrado",
      "bitBias": "Sesgo de Bits",
      "pass": "PASA",
      "warn": "ALERTA",
      "fail": "FALLA",
      "needSamples": "Se necesitan 1000+ muestras para ejecutar pruebas"
    },
    "templates": {
      "selectTemplate": "Selecciona una plantilla para derivar:",
      "forkAs": "Derivar como:",
      "defaultForkName": "Mi {name}"
    },
    "seed": {
      "label": "Semilla",
      "placeholder": "Ingrese valor de semilla"
    },
    "sampleSize": {
      "label": "Tama√±o de Muestra"
    },
    "controls": {
      "step": "Paso",
      "run": "Ejecutar",
      "autorun": "Auto",
      "stop": "Detener",
      "reset": "Reiniciar"
    },
    "algorithm": {
      "recommended": "Recomendado",
      "warnings": "Advertencias",
      "references": "Referencias"
    },
    "state": {
      "title": "Estado Interno",
      "stepCount": "Pasos",
      "empty": "Ejecuta un paso para ver el estado",
      "changed": "cambi√≥"
    },
    "output": {
      "title": "Salida",
      "lastValue": "√öltimo Valor",
      "noSamples": "A√∫n no se han generado muestras"
    },
    "histogram": {
      "title": "Distribuci√≥n",
      "yAxisLabel": "conteo",
      "empty": "Sin datos"
    },
    "correlation": {
      "title": "Gr√°fico de Correlaci√≥n",
      "xAxisLabel": "r[i]",
      "yAxisLabel": "r[i+1]",
      "empty": "Se necesitan 2+ muestras"
    },
    "timeSeries": {
      "title": "Serie Temporal",
      "xAxisLabel": "muestra #",
      "empty": "Sin datos"
    }
  },
  "footer": {
    "github": {
      "label": "GitHub",
      "aria_label": "Abrir repositorio de GitHub"
    }
  },
  "about": {
    "description": "Aprende c√≥mo los algoritmos PRNG transforman estado, semilla y entrop√≠a ‚Äî interactivamente."
  },
  "algorithms": {
    "tags": {
      "fast": "R√°pido",
      "modern": "Moderno",
      "educational": "Educativo",
      "legacy": "Legado"
    },
    "sfc32": {
      "name": "SFC32",
      "description": "Small Fast Counter - PRNG con estado de 128 bits. Pasa PractRand y BigCrush. Excelente calidad y velocidad.",
      "recommended": "Uso general, simulaciones, juegos"
    },
    "mulberry32": {
      "name": "Mulberry32",
      "description": "PRNG minimalista con estado de 32 bits. Muy r√°pido, pasa pruebas gjrand. Per√≠odo ~4 mil millones.",
      "recommended": "N√∫meros aleatorios r√°pidos cuando el tama√±o del estado importa",
      "warning": "Puede omitir aproximadamente 1/3 de todos los valores de 32 bits"
    },
    "splitmix32": {
      "name": "SplitMix32",
      "description": "Basado en el finalizador fmix32 de MurmurHash3. Estado de 32 bits, muy r√°pido.",
      "recommended": "Sembrar otros PRNGs, aplicaciones basadas en hash"
    },
    "xorshift32": {
      "name": "Xorshift32",
      "description": "Xorshift original de 32 bits de Marsaglia (2003). Estructura simple, valor educativo.",
      "recommended": "Aprender fundamentos de PRNG",
      "warning": "Falla muchas pruebas estad√≠sticas modernas. No para uso en producci√≥n."
    },
    "xoshiro128ss": {
      "name": "xoshiro128**",
      "description": "Derivado moderno de Xorshift (2018). Estado de 128 bits, r√°pido, buena calidad.",
      "recommended": "Uso general cuando se prefiere la familia xorshift",
      "warning": "Tiene problemas relacionados con LFSR en bits inferiores"
    },
    "lcg": {
      "name": "LCG (Park-Miller)",
      "description": "Generador Congruencial Lineal con par√°metros MINSTD. PRNG educativo cl√°sico.",
      "recommended": "Aprender sobre estructura y debilidades de PRNG",
      "warning": "Falla pruebas modernas r√°pidamente. Solo educativo."
    },
    "simpleCounter": {
      "name": "Contador Simple",
      "description": "El peor PRNG posible - solo incrementa en 1. Completamente predecible.",
      "recommended": "Aprender qu√© hace malo a un PRNG",
      "warning": "No es aleatorio en absoluto. Solo para comparaci√≥n educativa."
    },
    "references": {
      "pracrand": "PractRand",
      "mulberry32_gist": "Implementaci√≥n original",
      "splitmix_paper": "Art√≠culo SplitMix",
      "xorshift_paper": "Art√≠culo Xorshift RNGs",
      "xoshiro_paper": "Art√≠culo Scrambled Linear PRNGs",
      "lcg_wikipedia": "Wikipedia",
      "park_miller": "Art√≠culo Park-Miller"
    }
  },
  "dsl": {
    "error": {
      "unknownVariable": "Variable desconocida: {variable}",
      "tooManyOperations": "Demasiadas operaciones por paso",
      "outputVariableNotFound": "Variable de salida no encontrada: {variable}",
      "unknown": "Error desconocido"
    },
    "validate": {
      "nameRequired": "Se requiere el nombre del algoritmo",
      "stateRequired": "Se requiere al menos una variable de estado",
      "operationRequired": "Se requiere al menos una operaci√≥n",
      "undefinedVariable": "Operaci√≥n usa variable de estado indefinida: {variable}",
      "outputVariableNotFound": "Variable de salida no encontrada: {variable}"
    }
  },
  "operationDocs": {
    "title": "Referencia de Operaciones",
    "subtitle": "Aprende qu√© hace cada operaci√≥n",
    "introduction": "Estos son los bloques de construcci√≥n que usas para crear generadores de n√∫meros aleatorios. Cada operaci√≥n transforma n√∫meros de una manera espec√≠fica.",
    "whatAreBits": {
      "title": "¬øQu√© son los bits?",
      "content": "Las computadoras almacenan n√∫meros como secuencias de 0s y 1s llamados \"bits\". Por ejemplo, el n√∫mero 5 se almacena como 0101 en binario. Cada posici√≥n representa una potencia de 2: la m√°s a la derecha es 1, luego 2, luego 4, luego 8, y as√≠ sucesivamente. ¬°Entender los bits te ayuda a ver c√≥mo funcionan estas operaciones!"
    },
    "categories": {
      "arithmetic": "Operaciones Matem√°ticas",
      "arithmeticDesc": "Matem√°ticas b√°sicas como sumar y multiplicar n√∫meros",
      "bitwise": "Operaciones de Bits",
      "bitwiseDesc": "Operaciones que trabajan con bits individuales (0s y 1s)",
      "shift": "Operaciones de Desplazamiento",
      "shiftDesc": "Mueven bits a la izquierda o derecha dentro de un n√∫mero",
      "rotate": "Operaciones de Rotaci√≥n",
      "rotateDesc": "Mueven bits en c√≠rculo (no se pierde ning√∫n bit)"
    },
    "operations": {
      "add": {
        "name": "Suma",
        "brief": "Suma dos n√∫meros",
        "detailed": "¬°Igual que las matem√°ticas normales! Suma dos n√∫meros. Si el resultado es muy grande (m√°s de 4 mil millones), vuelve a empezar desde 0 - como el od√≥metro de un auto que da la vuelta.",
        "whyUseful": "La suma mezcla bien los n√∫meros porque el acarreo (como 9+1=10) causa que los cambios se propaguen por muchos d√≠gitos.",
        "example": "5 + 3 = 8",
        "exampleOverflow": "4.294.967.295 + 1 = 0 (¬°da la vuelta!)"
      },
      "sub": {
        "name": "Resta",
        "brief": "Resta un n√∫mero de otro",
        "detailed": "Resta normal. Si el resultado ser√≠a negativo, da la vuelta a un n√∫mero positivo grande.",
        "whyUseful": "Similar a la suma pero al rev√©s. Menos com√∫n en generadores aleatorios pero a√∫n √∫til.",
        "example": "5 - 3 = 2",
        "exampleOverflow": "0 - 1 = 4.294.967.295 (¬°da la vuelta!)"
      },
      "mul": {
        "name": "Multiplicaci√≥n",
        "brief": "Multiplica dos n√∫meros",
        "detailed": "Multiplica dos n√∫meros. Como la suma, si el resultado es muy grande, da la vuelta. La multiplicaci√≥n es muy poderosa para mezclar porque afecta muchos bits a la vez.",
        "whyUseful": "Multiplicar revuelve los bits muy efectivamente. Muchos de los mejores generadores aleatorios usan constantes de multiplicaci√≥n especiales.",
        "example": "3 √ó 5 = 15",
        "exampleOverflow": "Los n√∫meros grandes se ajustan para caber en 32 bits"
      },
      "mod": {
        "name": "M√≥dulo (Residuo)",
        "brief": "Obtiene el residuo despu√©s de dividir",
        "detailed": "Divide el primer n√∫mero por el segundo y te da el residuo. Como preguntar \"¬øqu√© sobra?\" Por ejemplo, 17 √∑ 5 = 3 residuo 2, entonces 17 mod 5 = 2.",
        "whyUseful": "Mantiene n√∫meros dentro de un rango espec√≠fico. Por ejemplo, n mod 100 siempre da un resultado entre 0 y 99.",
        "example": "17 % 5 = 2 (17 = 3√ó5 + 2, el residuo es 2)",
        "exampleOverflow": "10 % 3 = 1"
      },
      "xor": {
        "name": "XOR (O Exclusivo)",
        "brief": "Invierte bits donde las entradas difieren",
        "detailed": "Compara dos n√∫meros bit por bit. Si los bits son diferentes, el resultado es 1. Si son iguales, el resultado es 0. Pi√©nsalo como \"uno u otro, pero no ambos\".",
        "whyUseful": "¬°XOR es m√°gico para generadores aleatorios! Es reversible (A XOR B XOR B = A), mezcla bits sin perder informaci√≥n, y es muy r√°pido.",
        "example": "0101 XOR 0011 = 0110",
        "visualization": "Bit 1: ¬ø0‚â†0? No ‚Üí 0 | Bit 2: ¬ø1‚â†0? S√≠ ‚Üí 1 | Bit 3: ¬ø0‚â†1? S√≠ ‚Üí 1 | Bit 4: ¬ø1‚â†1? No ‚Üí 0"
      },
      "and": {
        "name": "AND (Y)",
        "brief": "Mantiene bits que son 1 en ambas entradas",
        "detailed": "Compara dos n√∫meros bit por bit. El resultado es 1 solo si AMBOS bits son 1. Pi√©nsalo como \"ambos deben estar de acuerdo\".",
        "whyUseful": "AND es genial para extraer bits espec√≠ficos de un n√∫mero (llamado \"enmascarar\"). Por ejemplo, n AND 255 extrae solo los √∫ltimos 8 bits.",
        "example": "0101 AND 0011 = 0001",
        "visualization": "Bit 1: 0 AND 0 = 0 | Bit 2: 1 AND 0 = 0 | Bit 3: 0 AND 1 = 0 | Bit 4: 1 AND 1 = 1"
      },
      "or": {
        "name": "OR (O)",
        "brief": "Activa bits que son 1 en cualquier entrada",
        "detailed": "Compara dos n√∫meros bit por bit. El resultado es 1 si CUALQUIER bit es 1. Pi√©nsalo como \"al menos uno dice s√≠\".",
        "whyUseful": "OR se usa para combinar bits o asegurar que ciertos bits est√©n activados. Menos com√∫n en generadores aleatorios que XOR.",
        "example": "0101 OR 0011 = 0111",
        "visualization": "Bit 1: 0 OR 0 = 0 | Bit 2: 1 OR 0 = 1 | Bit 3: 0 OR 1 = 1 | Bit 4: 1 OR 1 = 1"
      },
      "not": {
        "name": "NOT (Invertir Todos los Bits)",
        "brief": "Invierte cada bit",
        "detailed": "Invierte cada bit en el n√∫mero. Todos los 0s se vuelven 1s, y todos los 1s se vuelven 0s. Solo necesita una entrada.",
        "whyUseful": "NOT crea el \"opuesto\" de un n√∫mero. Rara vez se usa solo pero puede combinarse con otras operaciones.",
        "example": "NOT 0101 = 1010",
        "visualization": "Cada bit se invierte: 0‚Üí1 y 1‚Üí0"
      },
      "shl": {
        "name": "Desplazar a la Izquierda",
        "brief": "Mueve todos los bits a la izquierda",
        "detailed": "Mueve todos los bits a la izquierda un cierto n√∫mero de posiciones. Los espacios vac√≠os a la derecha se llenan con 0s. Los bits que salen por la izquierda se pierden.",
        "whyUseful": "Desplazar a la izquierda multiplica por potencias de 2. Desplazar 1 a la izquierda = multiplicar por 2. Tambi√©n es √∫til para mover bits a diferentes posiciones.",
        "example": "0001 << 2 = 0100 (desplazado 2 posiciones a la izquierda)",
        "visualization": "Original: 00000001 ‚Üí Despu√©s de << 2: 00000100"
      },
      "shr": {
        "name": "Desplazar a la Derecha (Con Signo)",
        "brief": "Mueve bits a la derecha, manteniendo el signo",
        "detailed": "Mueve todos los bits a la derecha. El bit m√°s a la izquierda (bit de signo) se copia para llenar espacios vac√≠os. Esto preserva si el n√∫mero es positivo o negativo.",
        "whyUseful": "Divide por potencias de 2 manteniendo el signo. Menos com√∫n en generadores aleatorios que el desplazamiento sin signo.",
        "example": "1000 >> 2 = 1110 (el bit de signo se propaga)",
        "visualization": "Para n√∫meros negativos, 1s llenan desde la izquierda"
      },
      "ushr": {
        "name": "Desplazar a la Derecha (Sin Signo)",
        "brief": "Mueve bits a la derecha, llenando con ceros",
        "detailed": "Mueve todos los bits a la derecha y siempre llena espacios vac√≠os con 0s. Trata el n√∫mero como positivo sin importar el bit m√°s a la izquierda.",
        "whyUseful": "La mayor√≠a de generadores aleatorios usan esto porque trabajan con patrones de bits, no n√∫meros con signo. ¬°Operaci√≥n muy com√∫n!",
        "example": "1000 >>> 2 = 0010 (ceros llenan desde la izquierda)",
        "visualization": "Original: 10000000 ‚Üí Despu√©s de >>> 2: 00100000"
      },
      "rotl": {
        "name": "Rotar a la Izquierda",
        "brief": "Rota bits a la izquierda (dan la vuelta)",
        "detailed": "Como desplazar a la izquierda, pero los bits que salen por la izquierda vuelven por la derecha. ¬°Nunca se pierde informaci√≥n - los bits solo se mueven en c√≠rculo!",
        "whyUseful": "La rotaci√≥n mezcla bits excelentemente sin perder ninguno. Muchos generadores aleatorios modernos usan rotaci√≥n porque es r√°pida y efectiva.",
        "example": "1001 rotl 1 = 0011 (el 1 de la izquierda pasa a la derecha)",
        "visualization": "Los bits se mueven en c√≠rculo: lado izquierdo ‚Üí lado derecho"
      },
      "rotr": {
        "name": "Rotar a la Derecha",
        "brief": "Rota bits a la derecha (dan la vuelta)",
        "detailed": "Como desplazar a la derecha, pero los bits que salen por la derecha vuelven por la izquierda. Igual que rotar a la izquierda pero en direcci√≥n opuesta.",
        "whyUseful": "Mismos beneficios que rotar a la izquierda. Combinado con XOR y suma, la rotaci√≥n crea una mezcla muy fuerte.",
        "example": "1001 rotr 1 = 1100 (el 1 de la derecha pasa a la izquierda)",
        "visualization": "Los bits se mueven en c√≠rculo: lado derecho ‚Üí lado izquierdo"
      }
    },
    "tips": {
      "title": "Consejos para Construir PRNGs",
      "tip1": "Combina diferentes tipos de operaciones (suma + XOR + desplazamiento) para mejor mezcla",
      "tip2": "Usa \"n√∫meros m√°gicos\" espec√≠ficos como constantes - han sido probados para funcionar bien",
      "tip3": "Aseg√∫rate de que cada bit se mezcle eventualmente - no dejes algunos bits sin cambiar",
      "tip4": "Prueba tu generador con las pesta√±as de Gr√°ficos y Pruebas para ver si es suficientemente aleatorio"
    },
    "tryIt": "¬°Pru√©balo!",
    "learnMore": "Aprender m√°s",
    "showDetails": "Mostrar detalles",
    "hideDetails": "Ocultar detalles"
  },
  "learn": {
    "title": "El Misterio de los N√∫meros M√°gicos",
    "subtitle": "Aprende c√≥mo las computadoras crean n√∫meros que parecen aleatorios",
    "resetProgress": "Reiniciar Progreso",
    "confirmReset": "¬øEst√°s seguro de que quieres reiniciar todo tu progreso de aprendizaje?",
    "completePrerequisites": "Completa el mundo anterior para desbloquear",
    "workshopUnlocked": {
      "title": "¬°Taller Desbloqueado!",
      "description": "Has ganado acceso al Taller completo. ¬°Experimenta libremente!"
    },
    "worlds": {
      "world1": {
        "title": "Mundo 1: Los N√∫meros que Recuerdan",
        "description": "Aprende sobre estado, memoria y variables",
        "badge": "Guardi√°n de N√∫meros"
      },
      "world2": {
        "title": "Mundo 2: Las Reglas Secretas",
        "description": "Aprende sobre multiplicaci√≥n, m√≥dulo y combinaci√≥n de operaciones",
        "badge": "Mezclador de Recetas"
      },
      "world2_5": {
        "title": "Mundo 2.5: Puente a los Bits",
        "description": "Introducci√≥n al pensamiento binario",
        "badge": "Explorador Binario"
      },
      "world3": {
        "title": "Mundo 3: La Danza de los Bits",
        "description": "Domina operaciones binarias como shift y XOR",
        "badge": "Maestro de Bits"
      },
      "world4": {
        "title": "Mundo 4: Constructores Maestros",
        "description": "Bifurca y modifica algoritmos PRNG reales",
        "badge": "Ingeniero de Aleatoriedad"
      },
      "world5": {
        "title": "Mundo 5: Laboratorio Avanzado",
        "description": "Algoritmos multi-estado y t√©cnicas avanzadas",
        "badge": "Investigador"
      }
    },
    "lessons": {
      "lesson1_1": {
        "title": "El N√∫mero Dormido",
        "objective": "Entender el concepto de variable/estado",
        "narrative": "Imagina que tienes una caja m√°gica. Dentro hay un n√∫mero - llam√©moslo el ESTADO. Este n√∫mero es especial porque recuerda d√≥nde est√°. Cada vez que miras dentro, ves el mismo n√∫mero... hasta que haces algo para cambiarlo. ¬°Esta 'memoria' es la base de c√≥mo las computadoras generan n√∫meros que parecen aleatorios!",
        "bridge": "Ese n√∫mero que acabas de revelar (42) es el ESTADO. Pero aqu√≠ est√° la clave: si aplicamos una REGLA a ese n√∫mero (como 'sumar 7' o 'multiplicar por 3'), obtenemos un NUEVO n√∫mero. Aplica la regla otra vez, obt√©n otro n√∫mero. Apl√≠cala 100 veces... ¬°obtienes una SECUENCIA de 100 n√∫meros! Y aqu√≠ est√° la magia: si dos cajas empiezan con el MISMO n√∫mero y usan la MISMA regla, ¬°producir√°n la EXACTA MISMA secuencia!",
        "completion": "¬°Descubriste que los n√∫meros pueden guardarse!",
        "quiz": {
          "q1": {
            "question": "Si dos cajas empiezan con el mismo n√∫mero, ¬øsiempre producir√°n la misma secuencia?",
            "optionA": "No, cada caja crea sus propios n√∫meros aleatorios",
            "optionB": "S√≠, el mismo n√∫mero inicial siempre da los mismos resultados",
            "optionC": "Depende del clima",
            "correct": "¬°Exacto! Esto se llama DETERMINISMO - la misma entrada siempre da la misma salida.",
            "incorrect": "Pi√©nsalo: si la caja sigue las mismas reglas y empieza igual..."
          }
        }
      },
      "lesson1_2": {
        "title": "La Semilla M√°gica",
        "objective": "Entender que el estado inicial importa",
        "narrative": "¬øY si pudieras elegir con qu√© n√∫mero empieza la caja? Ese n√∫mero especial de inicio se llama SEMILLA. Aqu√≠ est√° la idea poderosa: ¬°los juegos guardan la semilla para que los jugadores puedan repetir la misma experiencia 'aleatoria'! Los speedrunners comparten semillas para comparar partidas en mapas id√©nticos. Prueba diferentes semillas abajo - nota c√≥mo la MISMA semilla siempre produce la MISMA secuencia.",
        "reflection": "üîë IDEA CLAVE: ¬°Misma semilla = Misma secuencia, SIEMPRE! Por eso las semillas son tan poderosas. Los desarrolladores de juegos guardan semillas para recrear niveles. Los jugadores comparten semillas para competir en desaf√≠os id√©nticos. ¬°Los n√∫meros 'aleatorios' no son realmente aleatorios - est√°n completamente determinados por la semilla!",
        "completion": "¬°Aprendiste sobre semillas! Misma semilla = misma secuencia, siempre.",
        "quiz": {
          "q1": {
            "question": "¬øQu√© es una semilla?",
            "optionA": "Una planta",
            "optionB": "El n√∫mero con el que empieza la caja",
            "optionC": "Un tipo de magia",
            "correct": "¬°Exacto! La semilla es el n√∫mero inicial.",
            "incorrect": "Piensa en qu√© n√∫mero ponemos primero en la caja."
          }
        }
      },
      "lesson1_3": {
        "title": "El Contador Aburrido",
        "objective": "Primera transformaci√≥n (suma simple)",
        "narrative": "Ahora tu caja puede hacer algo: ¬°CONTAR! Cada vez que presionas el bot√≥n, el n√∫mero crece.",
        "completion": "Esto es PREDECIBLE. ¬øSer√° as√≠ el azar verdadero?",
        "quiz": {
          "q1": {
            "question": "¬øPodr√≠a tu amigo predecir el siguiente n√∫mero de este contador?",
            "optionA": "S√≠, siempre es el n√∫mero actual m√°s 1",
            "optionB": "No, es imposible adivinarlo",
            "optionC": "Solo si sabe matem√°ticas avanzadas",
            "correct": "¬°Exacto! Un contador simple es completamente PREDECIBLE - ¬°terrible para la aleatoriedad!",
            "incorrect": "Observa el patr√≥n: 1, 2, 3, 4... ¬øpuedes adivinar qu√© sigue?"
          }
        }
      },
      "lesson1_4": {
        "title": "¬øD√≥nde est√° el Misterio?",
        "objective": "Identificar que la suma simple NO es aleatoria",
        "narrative": "Comparemos dos generadores de n√∫meros diferentes...",
        "hint": "üëÄ QU√â OBSERVAR: En los gr√°ficos abajo, busca PATRONES. Un generador predecible muestra una l√≠nea diagonal clara (cada n√∫mero se relaciona con el siguiente de forma obvia). Un buen generador muestra puntos dispersos sin patr√≥n visible. ¬øCu√°l querr√≠as para un juego de dados?",
        "completion": "Has aprendido que los n√∫meros pueden recordar y cambiar, pero solo sumar es muy aburrido. Necesitamos REGLAS M√ÅS INTERESANTES...",
        "quiz": {
          "q1": {
            "question": "¬øPor qu√© no podemos usar un contador simple para un juego de dados?",
            "optionA": "Los contadores son muy lentos",
            "optionB": "Los contadores solo llegan hasta 6",
            "optionC": "Los jugadores podr√≠an predecir f√°cilmente el pr√≥ximo tiro",
            "correct": "¬°Correcto! La predictibilidad es enemiga de los juegos justos. ¬°Necesitamos n√∫meros impredecibles!",
            "incorrect": "Piensa qu√© pasar√≠a si tu oponente conociera el patr√≥n..."
          }
        }
      },
      "lesson2_1": {
        "title": "Multiplicaci√≥n Explosiva",
        "objective": "Ver c√≥mo la multiplicaci√≥n crea cambios dram√°ticos",
        "narrative": "Sumar es como caminar. Multiplicar es como... ¬°SALTAR!",
        "completion": "¬°Descubriste que la multiplicaci√≥n hace crecer los n√∫meros mucho m√°s r√°pido!",
        "quiz": {
          "q1": {
            "question": "¬øPor qu√© la multiplicaci√≥n crea patrones m√°s impredecibles que la suma?",
            "optionA": "La multiplicaci√≥n hace saltos m√°s grandes - peque√±os cambios tienen efectos dram√°ticos",
            "optionB": "La suma es en realidad m√°s impredecible",
            "optionC": "Son igualmente predecibles",
            "correct": "¬°Exacto! La multiplicaci√≥n amplifica los cambios dram√°ticamente. Ir de 5 a 6 (√ó1) es peque√±o, pero 5√ó3=15 a 6√ó3=18 - ¬°la diferencia crece!",
            "incorrect": "Pi√©nsalo: sumar 1 siempre suma 1. ¬°Pero multiplicar por 3 convierte un cambio de +1 en un cambio de +3!"
          }
        }
      },
      "lesson2_2": {
        "title": "El Problema del N√∫mero Gigante",
        "objective": "Entender el desbordamiento y los l√≠mites de memoria",
        "narrative": "¬øQu√© pasa si multiplicamos tantas veces que el n√∫mero ya no cabe? Las computadoras guardan n√∫meros en cajas de tama√±o fijo. Cuando un n√∫mero es demasiado grande, ¬°se DESBORDA y vuelve a empezar - como el od√≥metro de un carro que pasa de 999,999 a 000,000! En nuestra demostraci√≥n, usaremos una caja peque√±a (0-255) para verlo claramente. Los PRNGs reales usan cajas de 32 bits (0 a 4 mil millones), pero el principio es el mismo. Este 'accidente' es √öTIL para los PRNGs porque mezcla los n√∫meros de formas sorprendentes.",
        "completion": "Las computadoras tienen cajas de tama√±o fijo. ¬°Cuando se desbordan, dan la vuelta como un reloj!",
        "quiz": {
          "q1": {
            "question": "¬°El n√∫mero se desbord√≥ y dio la vuelta! ¬øEs esto un error o una caracter√≠stica para PRNGs?",
            "optionA": "Un error - deber√≠amos arreglarlo",
            "optionB": "¬°Una caracter√≠stica - ayuda a crear patrones impredecibles!",
            "optionC": "No importa - el desbordamiento nunca pasa en programas reales",
            "correct": "¬°Exacto! El desbordamiento es √öTIL porque mezcla el n√∫mero de formas inesperadas.",
            "incorrect": "Piensa: ¬øel desbordamiento hace los n√∫meros m√°s o menos predecibles?"
          }
        }
      },
      "lesson2_3": {
        "title": "El Cortador (M√≥dulo)",
        "objective": "Entender el operador m√≥dulo",
        "narrative": "¬øY si queremos un n√∫mero que nunca pase de 10? Usamos EL CORTADOR.",
        "primer": "Aqu√≠ hay un secreto: los dise√±adores de PRNG aman los n√∫meros PRIMOS (como 7, 13, 31, 127). ¬øPor qu√©? Cuando usas mod 10, patrones como 0-10-20-30 todos caen en el mismo lugar. ¬°Pero con mod 7 o mod 13, los n√∫meros se dispersan m√°s uniformemente - los primos no tienen factores comunes que creen atajos! Esto crea ciclos m√°s largos y patrones menos predecibles.",
        "completion": "¬°El operador m√≥dulo recorta los n√∫meros a su tama√±o!",
        "quiz": {
          "q1": {
            "question": "¬øCu√°nto es 17 mod 5?",
            "optionA": "2 - es el resto despu√©s de dividir 17 por 5",
            "optionB": "3 - porque 17 dividido por 5 es aproximadamente 3.4",
            "optionC": "12 - porque 17 menos 5 es 12",
            "correct": "¬°Correcto! 5 cabe en 17 tres veces (5√ó3=15), dejando un resto de 2.",
            "incorrect": "Piensa: ¬øcu√°ntas veces cabe 5 en 17? ¬øQu√© sobra?"
          }
        }
      },
      "lesson2_4": {
        "title": "Mezclando Recetas",
        "objective": "Combinar operaciones (multiplicar + sumar)",
        "narrative": "¬øQu√© pasa si usamos DOS reglas al mismo tiempo?",
        "warning": "‚ö†Ô∏è ¬°CUIDADO con las operaciones que rompen recetas! Algunas combinaciones destruyen toda la aleatoriedad. Por ejemplo: cualquier n√∫mero √ó 0 = 0. ¬°Una vez que llegas a cero, te quedas atrapado para siempre! ¬øPuedes detectar la operaci√≥n peligrosa en el siguiente quiz?",
        "completion": "¬°Combinar operaciones crea patrones m√°s interesantes!",
        "quiz": {
          "q1": {
            "question": "DEPURAR: Esta receta produce 0, 0, 0, 0... ¬øQu√© est√° mal?\n\nestado = estado √ó 2\nestado = estado √ó 0",
            "optionA": "La multiplicaci√≥n por 2 est√° mal",
            "optionB": "¬°Multiplicar por 0 destruye todo!",
            "optionC": "Necesitamos agregar m√°s pasos",
            "correct": "¬°Exacto! Cualquier cosa por 0 es igual a 0. ¬°Una mala operaci√≥n puede arruinar todo!",
            "incorrect": "¬øQu√© pasa cuando multiplicas CUALQUIER n√∫mero por 0?",
            "hint1": "Intenta calcular: 5 √ó 2 √ó 0 = ?"
          }
        }
      },
      "lesson2_5": {
        "title": "LCG: Tu Primer Generador Real",
        "objective": "Explorar un generador lineal real mediante fork",
        "narrative": "Los cient√≠ficos descubrieron una receta especial llamada LCG. ¬°Modifiquemos uno real!",
        "formula": "üìê LA F√ìRMULA LCG: estado = (estado √ó multiplicador + incremento) mod m√≥dulo. ¬°Eso es todo! Tres n√∫meros (multiplicador, incremento, m√≥dulo) definen todo el algoritmo. Los cient√≠ficos probaron MILLONES de combinaciones para encontrar las que producen buena aleatoriedad. El multiplicador 48271 que ver√°s abajo fue probado matem√°ticamente.",
        "completion": "¬°Has explorado un algoritmo PRNG real!",
        "quiz": {
          "q1": {
            "question": "Intenta cambiar el multiplicador del LCG de 48271 a solo 2. ¬øQu√© pasa con la calidad de salida?",
            "optionA": "La salida se ve igual - cualquier multiplicador funciona bien",
            "optionB": "La salida empeora - el n√∫mero original fue elegido cuidadosamente por matem√°ticos",
            "optionC": "La salida mejora - n√∫meros m√°s peque√±os son m√°s aleatorios",
            "correct": "¬°Exacto! Esas constantes espec√≠ficas (como 48271) fueron probadas extensivamente. ¬°Los n√∫meros que parecen aleatorios suelen funcionar mejor que los simples!",
            "incorrect": "Mira el histograma y el gr√°fico de correlaci√≥n despu√©s de cambiar el multiplicador. ¬øLos patrones parecen aleatorios?"
          }
        }
      },
      "lesson2_5_1": {
        "title": "El Juego de Adivinar",
        "objective": "Descubrir c√≥mo las preguntas s√≠/no encuentran n√∫meros r√°pido",
        "narrative": "¬øSab√≠as que las computadoras solo entienden dos cosas? S√ç y NO. ¬°Eso es todo! Juguemos un juego de adivinanzas - t√∫ eliges un n√∫mero y yo lo encontrar√© usando solo preguntas de s√≠/no. ¬°Mira qu√© r√°pido lo reducimos!",
        "binaryConnection": "üîó LA CONEXI√ìN BINARIA: Necesitaste exactamente 4 preguntas para 16 n√∫meros. ¬°No es coincidencia! Cada pregunta S√ç/NO es como un D√çGITO BINARIO (bit): 4 preguntas = 4 bits = 16 valores posibles. As√≠ es como las computadoras representan n√∫meros - con interruptores que est√°n ENCENDIDOS (1) o APAGADOS (0). ¬°8 bits = 256 valores, 32 bits = m√°s de 4 mil millones!",
        "completion": "¬°Con solo preguntas de s√≠/no puedes encontrar cualquier n√∫mero! Esta es la base del pensamiento binario.",
        "quiz": {
          "q1": {
            "question": "Para encontrar un n√∫mero del 1 al 16, ¬øqu√© estrategia es m√°s r√°pida?",
            "optionA": "Preguntar '¬øEs el 1? ¬øEs el 2? ¬øEs el 3?...' uno por uno (hasta 16 preguntas)",
            "optionB": "Preguntar '¬øEs mayor que 8?' y seguir dividiendo a la mitad (solo 4 preguntas)",
            "optionC": "Adivinar al azar",
            "correct": "¬°Exacto! Dividir a la mitad es mucho m√°s r√°pido: 16‚Üí8‚Üí4‚Üí2‚Üí1 en solo 4 pasos!",
            "incorrect": "Pi√©nsalo: verificar uno por uno podr√≠a tomar 16 intentos. ¬øCu√°ntas divisiones a la mitad para ir de 16 a 1?"
          }
        }
      },
      "lesson2_5_2": {
        "title": "N√∫meros con Interruptores",
        "objective": "Introducir representaci√≥n binaria de 4 bits",
        "narrative": "Imagina 4 interruptores. Cada uno puede estar ENCENDIDO o APAGADO. ¬°Juntos forman un n√∫mero!",
        "insight": "üéØ ¬°Acabas de explorar TODOS los 16 valores posibles con solo 4 interruptores! La f√≥rmula es simple: 2‚Å¥ = 16. Cada interruptor duplica las posibilidades: 1 interruptor = 2 valores, 2 interruptores = 4 valores, 3 interruptores = 8 valores, 4 interruptores = 16 valores. ¬°Este crecimiento exponencial es el poder secreto del binario!",
        "completion": "¬°Puedes representar cualquier n√∫mero del 0 al 15 con solo 4 interruptores!",
        "quiz": {
          "q1": {
            "question": "En un n√∫mero de 4 bits, ¬øqu√© posici√≥n de bit tiene el MAYOR impacto al cambiar?",
            "optionA": "¬°El bit de la izquierda (vale 8) - es el que m√°s cambia el n√∫mero!",
            "optionB": "El bit de la derecha (vale 1) - es el lugar de las 'unidades'",
            "optionC": "Todos los bits tienen igual impacto",
            "correct": "¬°Correcto! El bit de la izquierda vale 8, as√≠ que cambiarlo causa el mayor cambio!",
            "incorrect": "Piensa en los valores de posici√≥n: en 1111, el bit izquierdo vale 8, el derecho vale 1."
          }
        }
      },
      "lesson2_5_3": {
        "title": "M√°s Interruptores, N√∫meros M√°s Grandes",
        "objective": "Expandir a 8 bits, vista previa de 32 bits",
        "narrative": "¬øY si tuvi√©ramos M√ÅS interruptores? ¬°Podr√≠amos hacer n√∫meros M√ÅS GRANDES!",
        "primer": "Aqu√≠ est√° el poder de los bits: 8 bits = 256 posibilidades, 16 bits = 65,536, ¬°y 32 bits = m√°s de 4 MIL MILLONES! Cada bit extra DUPLICA las posibilidades. Los PRNGs reales usan 32 o 64 bits porque necesitan ENORMES cantidades de estados posibles - ¬°as√≠ los patrones no se repiten por miles de millones de pasos!",
        "completion": "Ahora entiendes c√≥mo las computadoras ven los n√∫meros. ¬°Es hora de aprender a BAILAR con bits!",
        "quiz": {
          "q1": {
            "question": "Cada bit adicional DUPLICA el n√∫mero de posibilidades. Si 4 bits = 16 valores, ¬øcu√°ntos valores dan 8 bits?",
            "optionA": "32 valores (16 + 16)",
            "optionB": "256 valores (16 √ó 16, o 2‚Å∏)",
            "optionC": "64 valores (16 √ó 4)",
            "correct": "¬°Exacto! Cada bit duplica: 4 bits = 16, 5 bits = 32, 6 bits = 64, 7 bits = 128, 8 bits = 256!",
            "incorrect": "Recuerda: cada nuevo bit DUPLICA las posibilidades, no las suma."
          }
        }
      },
      "lesson3_1": {
        "title": "El Desplazamiento (Moviendo Bits)",
        "objective": "Entender el desplazamiento de bits",
        "narrative": "¬øQu√© pasa si EMPUJAMOS todos los interruptores hacia la izquierda?",
        "completion": "¬°Desplazar a la izquierda es como multiplicar por 2, pero m√°s r√°pido para las computadoras!",
        "quiz": {
          "q1": {
            "question": "¬øPor qu√© el desplazamiento de bits podr√≠a ser MEJOR que la multiplicaci√≥n para un PRNG?",
            "optionA": "El desplazamiento es m√°s lento pero m√°s preciso",
            "optionB": "El desplazamiento es extremadamente r√°pido - las computadoras lo hacen en un ciclo de reloj",
            "optionC": "El desplazamiento hace patrones m√°s bonitos",
            "correct": "¬°Exacto! La velocidad importa para los PRNGs - ¬°pueden ser llamados millones de veces!",
            "incorrect": "Piensa en qu√© hace a un buen PRNG: calidad Y velocidad."
          }
        }
      },
      "lesson3_2": {
        "title": "XOR: El Detector de Diferencias",
        "objective": "Entender la operaci√≥n XOR",
        "narrative": "XOR es una regla especial: compara dos bits y verifica si son DIFERENTES.",
        "completion": "¬°XOR tiene una propiedad m√°gica: hacerlo dos veces te devuelve al original!",
        "quiz": {
          "q1": {
            "question": "XOR dos veces con el mismo n√∫mero devuelve el original. ¬øC√≥mo podr√≠a ser √∫til esto?",
            "optionA": "No es √∫til en absoluto",
            "optionB": "Puedes usarlo para 'ocultar' y 'revelar' datos - ¬°como encriptaci√≥n simple!",
            "optionC": "Solo funciona con n√∫meros primos",
            "correct": "¬°Correcto! XOR se usa en encriptaci√≥n, checksums y mezcla de bits en PRNGs.",
            "incorrect": "Piensa: si A XOR B XOR B = A, ¬øqu√© puedes hacer con esa propiedad?"
          }
        }
      },
      "lesson3_3": {
        "title": "La Mezcla Perfecta",
        "objective": "Combinar shift y XOR",
        "narrative": "Los magos de los n√∫meros descubrieron algo: si desplazas Y mezclas con XOR, ¬°los n√∫meros BAILAN!",
        "completion": "¬°Un peque√±o cambio en la entrada crea un GRAN cambio en la salida!",
        "quiz": {
          "q1": {
            "question": "¬øPor qu√© combinamos shift y XOR?",
            "optionA": "Hace los n√∫meros m√°s peque√±os",
            "optionB": "Crea cambios m√°s impredecibles",
            "optionC": "Hace que el c√≥digo corra m√°s r√°pido",
            "correct": "¬°Exacto! La combinaci√≥n mezcla los bits efectivamente.",
            "incorrect": "Piensa c√≥mo cada operaci√≥n afecta el patr√≥n."
          }
        }
      },
      "lesson3_4": {
        "title": "Xorshift: Tu Segundo Generador Real",
        "objective": "Explorar Xorshift mediante fork",
        "narrative": "Has aprendido los bloques de construcci√≥n: el desplazamiento mueve bits, XOR los mezcla. Ahora ve√°moslos trabajando juntos en un generador REAL llamado Xorshift. ¬°Este algoritmo fue inventado por George Marsaglia en 2003 y usa SOLO desplazamientos y XORs - sin multiplicaci√≥n! Prueba cambiar las cantidades de desplazamiento y observa qu√© pasa con la calidad de salida.",
        "comparisonIntro": "Ahora que has explorado Xorshift, compar√©moslo directamente con el LCG que aprendiste antes. Observa los gr√°ficos de correlaci√≥n lado a lado - ¬øqu√© algoritmo produce puntos m√°s dispersos (de aspecto aleatorio)?",
        "completion": "¬°Has dominado las operaciones m√°s poderosas. Es hora de construir generadores PROFESIONALES!",
        "quiz": {
          "q1": {
            "question": "¬øQu√© hace especial a Xorshift comparado con LCG?",
            "optionA": "Usa multiplicaci√≥n que es m√°s r√°pida",
            "optionB": "¬°Solo usa operaciones de desplazamiento y XOR - sin multiplicaci√≥n!",
            "optionC": "Produce peor calidad de salida",
            "correct": "¬°Exacto! Xorshift logra buena aleatoriedad usando solo operaciones simples de bits, haci√©ndolo muy r√°pido.",
            "incorrect": "Piensa en qu√© operaciones usa Xorshift. ¬øViste alguna multiplicaci√≥n?"
          }
        }
      },
      "lesson4_1": {
        "title": "Mulberry32: La M√°quina Industrial",
        "objective": "Explorar un algoritmo de producci√≥n real mediante fork",
        "narrative": "¬°Bienvenido a Mulberry32 - un generador realmente usado en juegos y aplicaciones! Observa c√≥mo combina todo lo que hemos aprendido: la suma crea caos, la multiplicaci√≥n mezcla a fondo, y XOR con copias desplazadas mezcla los bits. La 'constante m√°gica' 0x6D2B79F5 fue encontrada a trav√©s de millones de pruebas. ¬°Veamos qu√© pasa cuando la cambias!",
        "magicConstants": "üîÆ CONSTANTES M√ÅGICAS EXPLICADAS: ¬øPor qu√© 0x6D2B79F5? Estos n√∫meros hex raros crean lo que se llama 'efecto avalancha' - cambiar UN bit de entrada causa que aproximadamente la MITAD de los bits de salida cambien. Los investigadores prueban millones de candidatos y solo conservan aquellos que: 1Ô∏è‚É£ Pasan pruebas estad√≠sticas 2Ô∏è‚É£ Tienen buenas propiedades de mezcla de bits 3Ô∏è‚É£ No crean ciclos cortos. ¬°Intenta cambiarlo a 0x00000001 abajo y mira c√≥mo colapsa la calidad!",
        "completion": "¬°Has analizado un PRNG de grado profesional!",
        "quiz": {
          "q1": {
            "question": "¬øCu√°ntos tipos de operaciones usa Mulberry32?",
            "optionA": "Solo una (suma)",
            "optionB": "Dos (suma y multiplicaci√≥n)",
            "optionC": "Cuatro (suma, xor, shift, multiplicaci√≥n)",
            "correct": "¬°Correcto! Combina m√∫ltiples operaciones para mejor mezcla.",
            "incorrect": "Mira el algoritmo - usa suma, xor, shift y multiplicaci√≥n."
          }
        }
      },
      "lesson4_2": {
        "title": "El Laboratorio de Calidad",
        "objective": "Usar el conjunto completo de pruebas",
        "narrative": "Los cient√≠ficos usan pruebas especiales para verificar si los n√∫meros parecen verdaderamente aleatorios. ¬°Us√©moslas!",
        "testTypes": "üìä ENTENDIENDO LAS PRUEBAS: **Prueba de Media** - verifica si el promedio est√° cerca de 0.5 (el medio). Un generador sesgado podr√≠a favorecer n√∫meros altos o bajos. **Prueba Chi-Cuadrado** - verifica si los n√∫meros se distribuyen uniformemente. Incluso con buen promedio, los n√∫meros podr√≠an agruparse en ciertos rangos. **Prueba de Correlaci√≥n** - verifica si n√∫meros consecutivos est√°n relacionados. Un mal generador podr√≠a tener patrones como 'alto siempre sigue a bajo'. ¬°Necesitas pasar TODAS las pruebas para ser considerado aleatorio!",
        "completion": "¬°Ahora sabes c√≥mo evaluar cualquier generador cient√≠ficamente!",
        "quiz": {
          "q1": {
            "question": "¬øQu√© algoritmo pasa todas las pruebas de calidad?",
            "optionA": "Contador simple",
            "optionB": "Mulberry32",
            "optionC": "Las pruebas est√°n rotas y deben ignorarse",
            "correct": "¬°S√≠! Mulberry32 pasa todas las pruebas mientras el contador falla en todas.",
            "incorrect": "Revisa los resultados de las pruebas para cada algoritmo."
          }
        }
      },
      "lesson4_3": {
        "title": "El Desaf√≠o del Dise√±ador",
        "objective": "Crear tu propio generador",
        "narrative": "¬°Es hora de juntar todo! Has aprendido sobre suma, multiplicaci√≥n, XOR y desplazamientos. ¬°Ahora dise√±a TU PROPIO generador!",
        "guidance": "üõ†Ô∏è CONSEJOS DE DISE√ëO: ¬°Empieza simple y construye! 1Ô∏è‚É£ Comienza con solo 2 operaciones (ej: multiplicar luego XOR) 2Ô∏è‚É£ Usa multiplicadores impares (3, 5, 7) - n√∫meros pares crean patrones 3Ô∏è‚É£ Agrega operaciones de shift para esparcir cambios en los bits 4Ô∏è‚É£ Prueba con las visualizaciones - busca patrones dispersos, no l√≠neas 5Ô∏è‚É£ Si la salida se ve mal, prueba diferentes constantes. ¬°Los buenos dise√±os suelen usar n√∫meros primos!",
        "completion": "¬°Te has convertido en un dise√±ador de PRNG!",
        "quiz": {
          "q1": {
            "question": "Al dise√±ar un PRNG, ¬øqu√© es lo m√°s importante a considerar PRIMERO?",
            "optionA": "Hacerlo lo m√°s complejo posible con muchas operaciones",
            "optionB": "Asegurar que cada operaci√≥n realmente mejore la mezcla/calidad de aleatoriedad",
            "optionC": "Usar solo las operaciones m√°s nuevas y de moda",
            "correct": "¬°Exacto! Cada operaci√≥n debe tener un prop√≥sito. ¬°M√°s complejidad no significa mejor calidad!",
            "incorrect": "Piensa en lo que aprendiste: algunos generadores simples superan a los complejos. ¬øPor qu√©?"
          }
        }
      },
      "lesson4_4": {
        "title": "La Galer√≠a de Generadores",
        "objective": "Comparar todos los algoritmos aprendidos",
        "narrative": "Veamos c√≥mo se comparan todos los generadores que hemos aprendido.",
        "reflection": "üèÜ ¬°Mira cu√°nto has avanzado! Desde un simple contador que solo sumaba 1, hasta algoritmos sofisticados usando multiplicaci√≥n, XOR y desplazamientos de bits. Has visto c√≥mo cada t√©cnica mejora la calidad: los contadores son predecibles, LCG agrega mezcla, Xorshift usa operaciones de bits r√°pidas, y Mulberry32 combina todo en un generador listo para producci√≥n. ¬°Ahora est√°s listo para dise√±ar el tuyo!",
        "completion": "¬°Felicitaciones! Entiendes c√≥mo las computadoras crean n√∫meros que parecen aleatorios. ¬°Taller desbloqueado!",
        "quiz": {
          "q1": {
            "question": "¬øQu√© hace un buen PRNG?",
            "optionA": "Usar operaciones simples",
            "optionB": "Pasar pruebas de calidad y ser eficiente",
            "optionC": "Solo calidad - la velocidad no importa para computadoras modernas",
            "correct": "¬°Exacto! Un buen PRNG equilibra calidad con rendimiento.",
            "incorrect": "Piensa tanto en la calidad de aleatoriedad como en la velocidad."
          }
        }
      },
      "lesson5_1": {
        "title": "Algoritmos Multi-Estado",
        "objective": "Entender algoritmos con m√∫ltiples variables de estado",
        "narrative": "Hasta ahora, todos nuestros generadores usaban UNA variable de estado. ¬øPero qu√© si us√°ramos M√öLTIPLES variables que interact√∫an entre s√≠? Es como tener cuatro bailarines en vez de uno - ¬°sus interacciones crean patrones mucho m√°s dif√≠ciles de predecir! SFC32 usa 4 variables (a, b, c, contador) que se mezclan constantemente, ¬°creando 128 bits de estado en vez de solo 32!",
        "completion": "¬°M√∫ltiples variables de estado hacen los algoritmos m√°s dif√≠ciles de predecir!",
        "quiz": {
          "q1": {
            "question": "¬øPor qu√© los algoritmos avanzados usan m√∫ltiples variables de estado?",
            "optionA": "Es m√°s simple",
            "optionB": "M√°s dif√≠cil de predecir, per√≠odo m√°s largo",
            "optionC": "Es m√°s r√°pido",
            "correct": "¬°Correcto! M√∫ltiples variables interact√∫an de formas complejas.",
            "incorrect": "Piensa c√≥mo 4 variables pueden interactuar vs solo 1."
          }
        }
      },
      "lesson5_2": {
        "title": "xoshiro128**: El Moderno",
        "objective": "Explorar algoritmos modernos",
        "narrative": "Conoce xoshiro128** (pronunciado 'zoh-shee-roh'), creado en 2018 por Blackman y Vigna. ¬øQu√© lo hace de √∫ltima generaci√≥n? Usa ROTACI√ìN en vez de solo desplazamientos - la rotaci√≥n preserva TODOS los bits envolvi√©ndolos en lugar de perderlos por el borde. Combinado con 128 bits de estado en 4 variables, pasa las suites de pruebas m√°s rigurosas siendo incre√≠blemente r√°pido. El '**' en el nombre se refiere a su funci√≥n de mezcla que mejora a√∫n m√°s la calidad de salida.",
        "algorithmIntro": "¬°Ahora veamos la rotaci√≥n en acci√≥n dentro de un algoritmo real! xoshiro128** usa rotaci√≥n junto con 4 variables de estado que interact√∫an de formas complejas. Prueba modificar las cantidades de rotaci√≥n y observa c√≥mo afecta la calidad de salida.",
        "completion": "¬°Has explorado uno de los algoritmos PRNG m√°s modernos!",
        "quiz": {
          "q1": {
            "question": "xoshiro usa ROTACI√ìN en vez de solo desplazamientos. ¬øPor qu√© es mejor la rotaci√≥n?",
            "optionA": "La rotaci√≥n preserva TODOS los bits - ¬°nada se pierde! Los desplazamientos pierden bits por el borde",
            "optionB": "La rotaci√≥n es m√°s lenta pero m√°s bonita",
            "optionC": "La rotaci√≥n y los desplazamientos funcionan exactamente igual",
            "correct": "¬°Correcto! La rotaci√≥n envuelve los bits en vez de descartarlos, preservando la informaci√≥n.",
            "incorrect": "Cuando desplazas, los bits caen por un extremo. ¬øA d√≥nde van en la rotaci√≥n?"
          }
        }
      },
      "lesson5_3": {
        "title": "Interpretaci√≥n Avanzada de Pruebas",
        "objective": "Entender profundamente los resultados de las pruebas de calidad",
        "narrative": "Aprendamos qu√© mide realmente cada prueba y qu√© significan los fallos.",
        "realWorld": "‚ö†Ô∏è LA BRECHA DEL MUNDO REAL: Nuestras pruebas usan ~1,000 muestras. ¬°Pero los juegos podr√≠an llamar a un PRNG millones de veces! Un generador puede pasar pruebas simples pero mostrar patrones despu√©s de miles de millones de salidas. Por eso los profesionales usan TestU01 y PractRand - ejecutan TRILLONES de pruebas. Si tu juego parece 'con mala suerte' a pesar de pasar pruebas b√°sicas, el PRNG podr√≠a tener debilidades ocultas que solo aparecen a escala.",
        "completion": "¬°Ahora puedes interpretar resultados de pruebas como un verdadero cript√≥grafo!",
        "quiz": {
          "q1": {
            "question": "¬øQu√© mide la prueba de sesgo de bits?",
            "optionA": "Qu√© tan r√°pido es el algoritmo",
            "optionB": "Si cada bit tiene 50% de probabilidad de estar ENCENDIDO",
            "optionC": "El valor promedio de salida",
            "correct": "¬°Correcto! Cada bit debe ser igualmente probable de ser 0 o 1.",
            "incorrect": "Piensa qu√© significa 'sesgo' para bits individuales."
          }
        }
      },
      "lesson5_4": {
        "title": "Tu Proyecto Final",
        "objective": "Crear un generador original y documentarlo",
        "narrative": "Has viajado desde contadores simples hasta algoritmos multi-estado. Entiendes desplazamientos, XOR, multiplicaci√≥n y c√≥mo mezclan bits. ¬°Ahora es TU turno de dise√±ar un PRNG completo desde cero! Piensa en: ¬øQu√© operaciones usar√°s? ¬øQu√© constantes? ¬øC√≥mo asegurar√°s una buena mezcla? ¬°Documenta tus decisiones y prueba tu creaci√≥n!",
        "rubric": "üéØ CRITERIOS DE √âXITO para tu algoritmo: 1Ô∏è‚É£ Usa al menos 3 operaciones diferentes (suma, multiplicaci√≥n, xor, shift, etc.) 2Ô∏è‚É£ Evita operaciones 'asesinas' como multiplicar por 0 o sumar 0 3Ô∏è‚É£ Intenta pasar la prueba de media (los n√∫meros deben promediar cerca de 0.5) 4Ô∏è‚É£ Experimenta con diferentes constantes - ¬°los primos grandes suelen funcionar mejor! No te preocupes por hacerlo perfecto - el objetivo es ENTENDER c√≥mo las piezas funcionan juntas.",
        "completion": "üèÜ ¬°Felicitaciones! ¬°Has completado el curso avanzado y creado tu propio algoritmo documentado!",
        "quiz": {
          "q1": {
            "question": "Reflexionando sobre tu viaje: ¬øCu√°l es la lecci√≥n M√ÅS importante sobre los PRNGs?",
            "optionA": "Cuantas m√°s operaciones, mejor el generador",
            "optionB": "La calidad viene de entender c√≥mo las operaciones mezclan bits, no solo de la complejidad",
            "optionC": "La aleatoriedad real es imposible, as√≠ que no importa qu√© usemos",
            "correct": "¬°Exacto! Has aprendido que el dise√±o reflexivo supera la complejidad ciega. ¬°Esa es la marca de un verdadero ingeniero!",
            "incorrect": "Piensa: ¬øcu√°les generadores funcionaron mejor? ¬øLos m√°s complejos o los dise√±ados m√°s cuidadosamente?"
          }
        }
      }
    },
    "microTeaching": {
      "counting": {
        "concept": "Contar",
        "content": "Cuenta las manzanas: üçéüçéüçéüçéüçé = ?",
        "insight": "¬°Sumar significa contar hacia arriba!"
      },
      "multiplication": {
        "concept": "Multiplicaci√≥n",
        "content": "Antes de saltar, ¬°aprendamos qu√© significa multiplicar!",
        "insight": "¬°La multiplicaci√≥n es suma repetida, pero M√ÅS R√ÅPIDA!"
      },
      "remainder": {
        "concept": "Residuos",
        "content": "¬°Aprendamos sobre los sobrantes! 7 dulces para 3 amigos...",
        "insight": "¬°El residuo es lo que queda despu√©s de dividir equitativamente!"
      },
      "xor": {
        "concept": "XOR (O Exclusivo)",
        "content": "XOR compara dos bits: si son DIFERENTES, el resultado es 1. Si son IGUALES, el resultado es 0.",
        "insight": "¬øDiferentes? ENCENDIDO. ¬øIguales? APAGADO. ¬°Es como un detector de diferencias!"
      },
      "shift": {
        "concept": "Desplazamiento de Bits",
        "content": "Mover todos los bits a la izquierda o derecha, como deslizar fichas en un tablero.",
        "insight": "¬°Desplazar a la izquierda = multiplicar por 2. Desplazar a la derecha = dividir por 2!"
      },
      "shiftDemo": {
        "value": "N√∫mero",
        "amount": "Desplazar por",
        "left": "‚Üê Izquierda",
        "right": "‚Üí Derecha"
      },
      "xorDemo": {
        "valueA": "Valor A",
        "valueB": "Valor B",
        "random": "Aleatorio",
        "explanation": "XOR: Si los bits son diferentes ‚Üí 1. Si son iguales ‚Üí 0."
      },
      "binary": {
        "concept": "N√∫meros Binarios",
        "content": "Las computadoras usan solo ENCENDIDO y APAGADO (1 y 0) para representar todos los n√∫meros.",
        "insight": "¬°Con solo 8 interruptores puedes representar 256 n√∫meros diferentes!"
      },
      "overflow": {
        "concept": "L√≠mites de Memoria",
        "content": "Las computadoras guardan n√∫meros en cajas de tama√±o fijo. ¬øQu√© pasa cuando un n√∫mero es muy grande para caber?",
        "insight": "¬°Cuando un n√∫mero se desborda, da la vuelta como un od√≥metro que pasa de 999,999 a 000,000!"
      },
      "multiState": {
        "concept": "M√∫ltiples Variables",
        "content": "¬øY si en vez de UN bailar√≠n, tuvi√©ramos CUATRO bailarines movi√©ndose juntos? ¬°Sus interacciones ser√≠an mucho m√°s dif√≠ciles de predecir!",
        "insight": "¬°M√∫ltiples variables de estado interact√∫an y se mezclan, creando patrones mucho m√°s dif√≠ciles de descifrar!"
      },
      "shiftXorCombo": {
        "concept": "El Combo Poderoso",
        "content": "Shift MUEVE bits a nuevas posiciones. XOR MEZCLA bits. ¬øQu√© pasa cuando haces AMBOS? ¬°Cada bit afecta m√∫ltiples posiciones, creando una cascada de cambios!",
        "insight": "Shift + XOR = Efecto Avalancha. Cambia un bit y mira c√≥mo MUCHOS bits cambian. ¬°Este es el secreto de los PRNGs r√°pidos!"
      },
      "xorshift": {
        "concept": "El Algoritmo Xorshift",
        "content": "George Marsaglia descubri√≥ en 2003 que combinando solo TRES operaciones (shift izquierda, shift derecha, XOR) en el orden correcto se crea una aleatoriedad sorprendentemente buena. ¬°Sin multiplicaci√≥n!",
        "insight": "Xorshift demuestra que operaciones SIMPLES combinadas inteligentemente pueden rivalizar con algoritmos complejos. ¬°La magia est√° en las cantidades espec√≠ficas de desplazamiento!"
      },
      "binarySearch": {
        "concept": "Divide y Vencer√°s",
        "content": "Imagina encontrar un n√∫mero entre 1-100. Podr√≠as probar 1, 2, 3... O preguntar: '¬øEs mayor que 50?' ¬°Cada pregunta s√≠/no corta las posibilidades a la MITAD!",
        "insight": "Con preguntas s√≠/no, solo necesitas 7 intentos para 1-100. ¬°Ese es el poder de dividir a la mitad!"
      },
      "avalanche": {
        "concept": "El Efecto Avalancha",
        "content": "Los buenos PRNGs tienen una propiedad especial: cambiar solo UN bit de entrada deber√≠a cambiar aproximadamente la MITAD de los bits de salida. ¬°Como una peque√±a bola de nieve desatando una avalancha!",
        "insight": "¬°Las constantes m√°gicas como 0x6D2B79F5 fueron elegidas porque maximizan este efecto avalancha!"
      },
      "rotation": {
        "concept": "Rotaci√≥n de Bits",
        "content": "El desplazamiento pierde bits por el borde. ¬°Pero la ROTACI√ìN los envuelve! Los bits que caen por un lado reaparecen en el otro.",
        "insight": "La rotaci√≥n preserva TODA la informaci√≥n. Nunca se pierden bits, ¬°haci√©ndola perfecta para PRNGs!"
      },
      "testInterpretation": {
        "concept": "Leyendo Resultados de Pruebas",
        "content": "Las pruebas de calidad verifican cosas diferentes. Media verifica promedio. Chi-cuadrado verifica distribuci√≥n. Correlaci√≥n verifica patrones. ¬°Un generador debe pasar TODAS!",
        "insight": "Fallar una prueba revela la debilidad del generador. ¬°Cada prueba es como un detective buscando una pista diferente!"
      }
    },
    "microTeachingLabel": "Mini Lecci√≥n",
    "badges": {
      "collection": "Tus Insignias",
      "earnedOn": "Obtenido el {date}",
      "numberKeeper": {
        "name": "Guardi√°n de N√∫meros",
        "alt": "Insignia de Guardi√°n de N√∫meros - Una medalla p√∫rpura con una caja que contiene el n√∫mero 42",
        "description": "¬°Descubriste que los n√∫meros pueden guardarse!"
      },
      "recipeMixer": {
        "name": "Mezclador de Recetas",
        "alt": "Insignia de Mezclador de Recetas - Una medalla naranja con un taz√≥n de mezcla y s√≠mbolos matem√°ticos",
        "description": "¬°Aprendiste a combinar operaciones para crear recetas de n√∫meros!"
      },
      "binaryExplorer": {
        "name": "Explorador Binario",
        "alt": "Insignia de Explorador Binario - Una medalla verde con d√≠gitos binarios e interruptores",
        "description": "¬°Entiendes c√≥mo las computadoras ven los n√∫meros como bits!"
      },
      "bitMaster": {
        "name": "Maestro de Bits",
        "alt": "Insignia de Maestro de Bits - Una medalla azul con c√≠rculos XOR y flechas de desplazamiento",
        "description": "¬°Dominaste el baile de bits con XOR y desplazamientos!"
      },
      "randomnessEngineer": {
        "name": "Ingeniero de Aleatoriedad",
        "alt": "Insignia de Ingeniero de Aleatoriedad - Una medalla √°mbar con un engranaje y llave",
        "description": "¬°Puedes construir y probar generadores de n√∫meros aleatorios profesionales!"
      },
      "researcher": {
        "name": "Investigador",
        "alt": "Insignia de Investigador - Una medalla dorada con lupa, gr√°fico y documento",
        "description": "¬°Dominaste algoritmos avanzados y completaste el curso completo!"
      }
    },
    "operationTrace": {
      "title": "Traza Paso a Paso"
    },
    "comparison": {
      "title": "Comparaci√≥n de Algoritmos",
      "meanTest": "Prueba de Media",
      "varianceTest": "Prueba de Varianza",
      "score": "Puntuaci√≥n de Calidad"
    },
    "worldLesson": "Mundo {world} ¬∑ Lecci√≥n {lesson}",
    "continue": "Continuar",
    "previous": "Anterior",
    "finish": "Finalizar",
    "checkAnswer": "Verificar Respuesta",
    "nextQuestion": "Siguiente Pregunta",
    "enterAnswer": "Ingresa tu respuesta",
    "activities": {
      "wakeUp": "Despertar el n√∫mero",
      "enterNumber": "Ingresa un n√∫mero...",
      "yourNumber": "¬°Ese es TU n√∫mero especial: {number}!",
      "seed": "Semilla",
      "currentNumber": "N√∫mero actual",
      "nextNumber": "Siguiente n√∫mero",
      "reset": "Reiniciar",
      "counter": "Contador Simple",
      "counterDesc": "Solo suma 1 cada vez (¬°predecible!)",
      "professional": "Generador Profesional",
      "algorithmDesc": "Usa mezcla matem√°tica",
      "stepBoth": "Avanzar Ambos",
      "comparisonIntro": "Compara un contador simple con un algoritmo PRNG real. ¬°Nota la diferencia de patr√≥n!",
      "comparisonHint": "El contador muestra una l√≠nea diagonal (predecible). Los buenos PRNGs muestran puntos dispersos (impredecibles).",
      "addVsMultiply": {
        "intro": "¬°Compara c√≥mo la SUMA vs la MULTIPLICACI√ìN afectan los patrones de n√∫meros!",
        "multiplier": "Multiplicador",
        "addTitle": "Solo Suma",
        "addFormula": "estado = estado + {n}",
        "mulTitle": "Multiplicaci√≥n",
        "mulFormula": "estado = estado √ó {n}",
        "step": "Avanzar Ambos",
        "runMany": "Ejecutar 20 Pasos",
        "hint": "¬°Nota c√≥mo la suma crea un ascenso constante, mientras que la multiplicaci√≥n salta m√°s dram√°ticamente!"
      },
      "overflowExplanation": "¬°Cuando multiplicamos m√°s all√° de {max}, el n√∫mero da la vuelta!",
      "multiply": "Multiplicar √ó{n}",
      "forkExplore": "Explora este algoritmo modificando sus constantes y observando los resultados.",
      "tryThis": "Prueba este experimento:",
      "forkExploreAlgorithm": "Algoritmo:",
      "forkExploreHint": "Haz clic en 'Editar Constantes' arriba para modificar valores. ¬°Observa c√≥mo los cambios afectan los patrones de salida!",
      "forkExploreHintLcg": "üí° Intenta esto: Cambia el 'mul const' de 48271 a solo 2. ¬°Nota c√≥mo el gr√°fico de correlaci√≥n cambia de disperso a l√≠neas diagonales!",
      "forkExploreHintXorshift": "üí° Intenta esto: Cambia una de las cantidades de desplazamiento a 0 o 32. ¬°Observa c√≥mo rompe la mezcla de bits y crea patrones visibles!",
      "forkExploreHintMulberry": "üí° Intenta esto: Cambia 0x6D2B79F5 a 0x00000001. La constante m√°gica fue elegida cuidadosamente - ¬°mira qu√© pasa sin ella!",
      "forkExploreHintMultiState": "üí° Este algoritmo usa 4 variables trabajando juntas. ¬°Intenta cambiar una constante y observa c√≥mo afecta todos los valores de estado!",
      "algorithmExplorer": {
        "state": "Estado Actual",
        "output": "Salida",
        "step": "Paso",
        "timeSeries": "Salida en el Tiempo",
        "correlation": "Gr√°fico de Correlaci√≥n",
        "histogram": "Distribuci√≥n",
        "binaryView": "Vista Binaria",
        "steps": "{count} pasos generados",
        "constants": "Constantes del Algoritmo",
        "editConstants": "Editar Constantes",
        "doneEditing": "Listo",
        "editHint": "Cambia los valores y observa c√≥mo afecta la salida. Usa hex (0x...) para n√∫meros grandes.",
        "modified": "modificado",
        "multiStateInfo": "Estas variables interact√∫an entre s√≠ en cada paso",
        "totalStateBits": "¬°{bits} bits de estado total = astron√≥micamente m√°s combinaciones!"
      },
      "qualityLab": {
        "title": "Laboratorio de Calidad",
        "intro": "Ejecuta pruebas en diferentes algoritmos para ver cu√°les producen mejores n√∫meros aleatorios.",
        "runTests": "Ejecutar Pruebas",
        "comparing": "Comparando algoritmos...",
        "testMean": "Prueba de Media",
        "testVariance": "Prueba de Varianza",
        "testChiSquare": "Prueba Chi-Cuadrado",
        "passed": "APROBADO",
        "failed": "FALLIDO"
      },
      "designerChallenge": {
        "title": "Desaf√≠o de Dise√±o",
        "intro": "¬°Crea tu propio generador que pase todas las pruebas!",
        "challenge1": "Pasar la prueba del histograma",
        "challenge2": "Usar 5 o menos operaciones",
        "challenge3": "Pasar todas las pruebas de calidad",
        "completed": "¬°Desaf√≠o completado!",
        "tryAgain": "¬°Sigue intentando!"
      },
      "testInterpretation": {
        "title": "Entendiendo los Resultados",
        "intro": "¬°Diagnostica qu√© est√° mal con estos generadores bas√°ndote en sus resultados de pruebas!",
        "reference": "üìñ Gu√≠a de Referencia de Pruebas (clic para expandir)",
        "meanExplain": "Verifica si los n√∫meros promedian 0.5 (el medio del rango 0-1).",
        "varianceExplain": "Mide qu√© tan dispersos est√°n tus n√∫meros.",
        "chiSquareExplain": "Verifica si los n√∫meros est√°n distribuidos uniformemente en todos los rangos.",
        "scenario": "Escenario {n}",
        "question": "¬øQu√© est√° mal probablemente con este generador?",
        "options": {
          "clumpy": "Los n√∫meros se agrupan en ciertos rangos en vez de dispersarse uniformemente",
          "biased": "Los n√∫meros tienden hacia valores altos o bajos (no centrados)",
          "tooNarrow": "Los n√∫meros no se dispersan lo suficiente (muy cercanos entre s√≠)",
          "perfect": "Nada - el generador funciona bien"
        },
        "explanations": {
          "clumpy": "Fallo en Chi-Cuadrado significa distribuci√≥n desigual - algunos rangos reciben muchos n√∫meros, otros muy pocos.",
          "biased": "Fallo en Media indica que el promedio no est√° centrado en 0.5, as√≠ que los n√∫meros se inclinan alto o bajo.",
          "tooNarrow": "Fallo en Varianza significa que los n√∫meros se agrupan muy cerca de la media en vez de dispersarse."
        },
        "correct": "¬°Correcto! Lo diagnosticaste bien.",
        "incorrect": "No exactamente. Mira qu√© prueba fall√≥ y qu√© mide.",
        "nextScenario": "Siguiente Escenario",
        "allComplete": "¬°Excelente Trabajo!",
        "summary": "¬°Ahora puedes interpretar resultados de pruebas como un verdadero ingeniero de PRNG!",
        "tryAgain": "Practicar de Nuevo"
      },
      "finalProject": {
        "title": "Tu Proyecto Final",
        "intro": "¬°Dise√±a y documenta tu propio algoritmo PRNG!",
        "buildAlgorithm": "Construye tu algoritmo eligiendo operaciones:",
        "qualityScore": "Puntuaci√≥n de Calidad",
        "steps": "{count} pasos generados"
      },
      "seedDemo": {
        "tryPresets": "Prueba estas semillas predefinidas:",
        "orTryOwn": "O prueba tu propia semilla:",
        "enterSeed": "Ingresa semilla",
        "try": "Probar",
        "seedValue": "Semilla",
        "produces": "produce esta secuencia:",
        "hint": "Misma semilla = misma secuencia. ¬°Diferente semilla = diferente secuencia!"
      },
      "determinismDemo": {
        "title": "Dos Cajas, Misma Semilla",
        "intro": "Observa qu√© pasa cuando dos generadores de n√∫meros comienzan con la MISMA semilla y siguen las MISMAS reglas.",
        "boxA": "Caja A",
        "boxB": "Caja B",
        "stepBoth": "Avanzar Ambas",
        "identical": "‚úì ¬°Ambas cajas producen los MISMOS n√∫meros EXACTOS!",
        "different": "Las secuencias son diferentes",
        "hint": "Prueba diferentes semillas - ¬°mientras ambas cajas comiencen igual, siempre coincidir√°n!"
      },
      "binaryGame": {
        "thinkOfNumber": "Piensa en un n√∫mero entre 1 y 16. ¬°Lo encontrar√© con solo preguntas de s√≠/no!",
        "range": "Elige cualquier n√∫mero del {min} al {max}",
        "question": "¬øTu n√∫mero es mayor que {mid}?",
        "yes": "S√≠",
        "no": "No",
        "found": "¬°Tu n√∫mero es {number}!",
        "guessCount": "¬°Lo encontr√© en solo {count} preguntas!",
        "playAgain": "Jugar de Nuevo",
        "history": "Preguntas realizadas:"
      },
      "shiftDemo": {
        "current": "Valor Actual",
        "shiftBy": "Desplazar por:",
        "shiftLeft": "Desplazar Izquierda",
        "shiftRight": "Desplazar Derecha",
        "history": "Historial de Desplazamientos"
      },
      "xorExperiment": {
        "intro": "¬°Prueba diferentes valores para A y B. Observa c√≥mo XOR compara cada bit!",
        "result": "A XOR B =",
        "hint": "Nota: cuando los bits son DIFERENTES ‚Üí 1, cuando son IGUALES ‚Üí 0",
        "reversibilityTitle": " La Propiedad M√°gica: ¬°XOR es Reversible!",
        "backToA": "¬°Vuelve a A!",
        "reversibilityHint": "¬°Aplica XOR al resultado con B de nuevo, y recuperas el A original! Por eso XOR se usa en encriptaci√≥n."
      },
      "shiftXor": {
        "current": "Estado Actual",
        "formula": "Cada paso: estado ^= estado << 7; estado ^= estado >>> 5",
        "step": "Paso"
      },
      "rotationVsShift": {
        "title": "Rotaci√≥n vs Desplazamiento: Por qu√© Gana la Rotaci√≥n",
        "value": "N√∫mero",
        "amount": "Mover por",
        "random": "Aleatorio",
        "original": "Valor Original",
        "shiftLeft": "‚Üê Desplazar Izq",
        "rotateLeft": "‚Üª Rotar Izq",
        "bitsLost": "¬°Los bits caen por el borde!",
        "bitsPreserved": "¬°Los bits dan la vuelta!",
        "lost": "Perdidos para siempre",
        "wrapped": "Regresaron",
        "explanation": "El desplazamiento pierde bits que caen por el borde. La rotaci√≥n los envuelve - ¬°nunca se pierde informaci√≥n! Por eso los PRNGs modernos prefieren la rotaci√≥n."
      },
      "comparativeTable": {
        "title": "Resumen de Comparaci√≥n de Algoritmos",
        "algorithm": "Algoritmo",
        "mean": "Media",
        "variance": "Varianza",
        "chiSquare": "Chi¬≤",
        "quality": "Calidad",
        "legend": "‚úì = prueba aprobada, ‚úó = prueba fallida. M√°s estrellas = mejor calidad general."
      }
    },
    "sandbox": {
      "title": "Tu M√°quina de N√∫meros",
      "step": "Paso {count}",
      "state": "Valor actual",
      "nextStep": "Siguiente Paso",
      "reset": "Reiniciar",
      "allowedOperations": "Operaciones disponibles"
    },
    "modulo": {
      "title": "La Rueda del M√≥dulo (mod {mod})",
      "value": "Valor",
      "reset": "Reiniciar",
      "modBy": "Mod por",
      "prime": "primo",
      "enterValue": "Ingresa un n√∫mero",
      "set": "Establecer"
    },
    "multiplication": {
      "title": "La Tabla de Multiplicar",
      "explanation": "{rows} filas de {cols} = {result} en total",
      "clear": "Limpiar"
    },
    "bits": {
      "title": "Toggle de {count} Bits",
      "decimal": "Decimal",
      "binary": "Binario",
      "hex": "Hex",
      "clear": "Limpiar",
      "max": "M√°x",
      "range": "Rango: {min} a {max}",
      "preview32Title": "¬øY con 32 bits?",
      "preview32Possibilities": "Con 32 bits: ¬°{count} valores posibles!",
      "preview32Explanation": "Los PRNGs reales usan 32 bits (o m√°s) para tener astron√≥micamente m√°s posibilidades"
    },
    "calculator": {
      "title": "Calculadora por Pasos",
      "currentValue": "Valor Actual",
      "operand": "N√∫mero",
      "apply": "Aplicar",
      "history": "Pasos",
      "undo": "Deshacer",
      "reset": "Reiniciar"
    },
    "candy": {
      "title": "Repartir los Dulces",
      "candies": "Dulces",
      "friends": "Amigos",
      "leftover": "¬°Sobran!",
      "remainder": "(resto {r})",
      "insight": "El resto es lo que sobra cuando no puedes dividir exactamente. ¬°Esto es exactamente lo que calcula 'mod' (m√≥dulo)!"
    },
    "counting": {
      "title": "Contando Paso a Paso",
      "insight": "Sumar 1 cada vez es la transformaci√≥n m√°s simple. Es predecible - ¬°por eso NO es aleatorio!"
    },
    "overflow": {
      "title": "Od√≥metro de 8 Bits",
      "bitLimit": "L√≠mite de {bits} bits: 0 a {max}",
      "wrapped": "¬°Desbordamiento! Volvi√≥ a 0",
      "nearMax": "Cerca del M√°x",
      "tryAdding": "¬°Intenta sumar n√∫meros para ver qu√© pasa en el l√≠mite!",
      "almostThere": "¬°Casi! Solo faltan {remaining} para el desbordamiento...",
      "explanation": "¬°El n√∫mero se hizo muy grande! Como un od√≥metro de auto, volvi√≥ a 0."
    },
    "multiState": {
      "title": "Cuatro Variables Bailando",
      "steps": "Pasos",
      "possibleStates": "Estados Posibles",
      "step": "Paso",
      "mixed": "¬°Las variables se mezclaron!",
      "insight": "4 variables √ó 256 valores cada una = ¬°m√°s de 4 MIL MILLONES de estados posibles!"
    }
  }
}
