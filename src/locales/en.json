{
  "app": {
    "title": "PRNG School",
    "description": "Learn how PRNG algorithms transform state, seed, and entropy ‚Äî interactively.",
    "welcome": {
      "badge": "Welcome",
      "title": "Welcome to PRNG School",
      "description": "Learn how PRNG algorithms transform state, seed, and entropy ‚Äî interactively."
    }
  },
  "home": {
    "hero": {
      "badge": "Interactive Learning Lab",
      "title": "Discover the Magic Behind Random Numbers",
      "subtitle": "Explore how computers generate numbers that seem random. Learn, experiment, and build your own algorithms ‚Äî no prior experience needed.",
      "startLearning": "Start Learning",
      "openWorkshop": "Open Workshop"
    },
    "features": {
      "title": "What You'll Explore",
      "learn": {
        "title": "Learn Mode",
        "description": "Journey through 6 worlds with guided lessons. Discover state, seeds, binary operations, and real PRNG algorithms step by step.",
        "highlights": {
          "worlds": "6 progressive worlds",
          "badges": "Earn badges as you learn",
          "interactive": "Hands-on activities & quizzes"
        }
      },
      "workshop": {
        "title": "Algorithm Workshop",
        "description": "Create your own PRNGs using a safe visual builder or code editor. Test quality with real statistical tools.",
        "highlights": {
          "dsl": "Visual & code editors",
          "preview": "Real-time visualization",
          "tests": "Quality test suite"
        }
      },
      "algorithms": {
        "title": "Built-in Algorithms",
        "description": "Study 7 real PRNG implementations ‚Äî from simple counters to production-ready generators like SFC32 and Xoshiro128**.",
        "highlights": {
          "production": "Production-ready PRNGs",
          "educational": "Educational examples",
          "fork": "Fork & modify any algorithm"
        }
      }
    },
    "highlights": {
      "title": "Built for Learning",
      "safe": {
        "title": "Safe by Design",
        "description": "DSL-based algorithm creation prevents arbitrary code execution. Experiment freely!"
      },
      "responsive": {
        "title": "Always Responsive",
        "description": "Web Workers keep the UI smooth even during long computations."
      },
      "languages": {
        "title": "Multiple Languages",
        "description": "Available in English and Spanish. More coming soon!"
      },
      "themes": {
        "title": "Light & Dark Themes",
        "description": "Choose your preferred appearance for comfortable learning."
      }
    },
    "cta": {
      "title": "Ready to Begin?",
      "description": "Start with the fundamentals or jump straight into the Workshop if you're feeling adventurous.",
      "beginJourney": "Begin Your Journey"
    }
  },
  "common": {
    "generate": "Generate",
    "copy": "Copy",
    "save": "Save",
    "cancel": "Cancel",
    "close": "Close",
    "delete": "Delete",
    "loading": "Loading...",
    "success": "Success!",
    "error": "Error",
    "warning": "Warning",
    "unknown": "Unknown",
    "unknownError": "Unknown error",
    "example": "Example"
  },
  "prngRunner": {
    "errors": {
      "algorithmNotFound": "Algorithm \"{id}\" not found",
      "failedToInitialize": "Failed to initialize",
      "invalidValue": "Generator produced invalid value (NaN or Infinite)",
      "valueOutOfRange": "Value out of range [0, 1): {value}",
      "stepFailed": "Step failed"
    }
  },
  "theme": {
    "selector": {
      "aria_label": "Change theme to {theme}"
    },
    "options": {
      "light": "Light",
      "dark": "Dark",
      "system": "System"
    }
  },
  "language": {
    "selector": {
      "aria_label": "Change language to {language}"
    }
  },
  "navigation": {
    "home": "Home",
    "learn": "Learn",
    "about": "About",
    "workshop": "Workshop",
    "toggleMenu": "Toggle menu"
  },
  "workshop": {
    "title": "Algorithm Workshop",
    "description": "Create, edit, and experiment with your own PRNG algorithms",
    "showHelp": "Help",
    "hideHelp": "Hide Help",
    "createNew": "New Algorithm",
    "algorithms": "Your Algorithms",
    "noAlgorithms": "No algorithms yet. Create your first one!",
    "untitled": "Untitled",
    "forkedFrom": "Forked from",
    "fork": "Fork",
    "custom": "Custom",
    "editor": "Editor",
    "name": "Name",
    "namePlaceholder": "My PRNG",
    "algorithmDescription": "Description",
    "descriptionPlaceholder": "Describe your algorithm...",
    "stateVariables": "State Variables",
    "addVariable": "Add Variable",
    "outputVariable": "Output Variable",
    "operations": "Operations",
    "addOperation": "Add Operation",
    "customConst": "Custom...",
    "preview": "Live Preview",
    "forkBuiltin": "Fork Built-in",
    "testSeed": "Test Seed",
    "runSize": "Run Size",
    "autoDuration": "Auto (s)",
    "moveUp": "Move up",
    "moveDown": "Move down",
    "editorModes": {
      "visual": "Visual",
      "code": "Code"
    },
    "codeEditor": {
      "label": "Operations Code",
      "placeholder": "s = s + 1\ns = s ^ 0x9e3779b9\ns = s >>> 13\ns = rotl(s, 5)",
      "format": "Format",
      "revert": "Revert",
      "apply": "Apply",
      "newVariables": "New variables will be created (initial value 0): {vars}",
      "errorAt": "Line {line}, Col {column}: {message}",
      "toast": {
        "applied": "Applied",
        "fixErrorsBeforeApply": "Fix errors before applying",
        "fixErrorsBeforeFormat": "Fix errors before formatting",
        "needOneOperation": "Add at least one operation"
      },
      "errors": {
        "invalid_statement": "Invalid statement (expected: target = expression)",
        "invalid_target": "Invalid target: {target}",
        "invalid_expression": "Invalid expression",
        "invalid_operand": "Invalid operand: {token}",
        "invalid_number": "Invalid number: {token}",
        "amount_must_be_number": "Shift/rotate amount must be a number (0-31): {token}",
        "amount_out_of_range": "Shift/rotate amount out of range (0-31): {amount}",
        "unsupported_operator": "Unsupported operator: {operator}",
        "unsupported_function": "Unsupported function",
        "unknown": "Unknown error"
      }
    },
    "previewTabs": {
      "state": "State",
      "charts": "Charts",
      "tests": "Tests"
    },
    "previewPanel": {
      "stateEmpty": "Click {action} to generate samples",
      "chartsEmpty": "Run the algorithm to see visualizations"
    },
    "autoTests": {
      "title": "Quality Tests",
      "runTests": "Run Tests",
      "mean": "Mean",
      "variance": "Variance",
      "expected": "expected",
      "chiSquare": "Chi-Square",
      "bitBias": "Bit Bias",
      "pass": "PASS",
      "warn": "WARN",
      "fail": "FAIL",
      "needSamples": "Need 1000+ samples to run tests"
    },
    "templates": {
      "selectTemplate": "Select a template to fork:",
      "forkAs": "Fork as:",
      "defaultForkName": "My {name}"
    },
    "seed": {
      "label": "Seed",
      "placeholder": "Enter seed value"
    },
    "sampleSize": {
      "label": "Sample Size"
    },
    "controls": {
      "modulo": {
        "title": "Modulo {mod} Wheel",
        "value": "Value",
        "enterValue": "Enter number",
        "set": "Set",
        "reset": "Reset",
        "modBy": "Mod by",
        "prime": "prime"
      },
      "step": "Step",
      "run": "Run",
      "autorun": "Auto",
      "stop": "Stop",
      "reset": "Reset"
    },
    "algorithm": {
      "recommended": "Recommended",
      "warnings": "Warnings",
      "references": "References"
    },
    "state": {
      "title": "Internal State",
      "stepCount": "Steps",
      "empty": "Run a step to see state",
      "changed": "changed"
    },
    "output": {
      "title": "Output",
      "lastValue": "Last Value",
      "noSamples": "No samples generated yet"
    },
    "histogram": {
      "title": "Distribution",
      "yAxisLabel": "count",
      "empty": "No data"
    },
    "correlation": {
      "title": "Correlation Plot",
      "xAxisLabel": "r[i]",
      "yAxisLabel": "r[i+1]",
      "empty": "Need 2+ samples"
    },
    "timeSeries": {
      "title": "Time Series",
      "xAxisLabel": "sample #",
      "empty": "No data"
    }
  },
  "footer": {
    "github": {
      "label": "GitHub",
      "aria_label": "Open GitHub repository"
    }
  },
  "about": {
    "title": "About PRNG School",
    "intro": {
      "title": "What is PRNG School?",
      "description": "PRNG School is an interactive learning lab for exploring pseudorandom number generators. It's designed for hands-on discovery ‚Äî understanding how PRNGs work, experimenting with parameters, and even building your own algorithms.",
      "disclaimer": "This is an educational tool. Implementations and analyses are for learning, not production or cryptographic use."
    },
    "features": {
      "title": "Features",
      "learnMode": {
        "title": "Learn Mode",
        "description": "Structured lessons with progress tracking across 6 worlds, from basic state concepts to advanced multi-state algorithms."
      },
      "workshop": {
        "title": "Workshop",
        "description": "Create and test custom PRNG algorithms using a constrained DSL with visual and code editing modes."
      },
      "algorithms": {
        "title": "Built-in Algorithms",
        "description": "Study SFC32, Mulberry32, SplitMix32, Xoshiro128**, Xorshift32, LCG, and Simple Counter implementations."
      },
      "visualization": {
        "title": "Visualization",
        "description": "Real-time charts including time series, correlation plots, and distribution histograms."
      },
      "qualityTests": {
        "title": "Quality Tests",
        "description": "Statistical tests including mean, variance, chi-square, and bit bias analysis."
      },
      "i18n": {
        "title": "Internationalization",
        "description": "Full support for English and Spanish languages."
      }
    },
    "technical": {
      "title": "Technical Details",
      "stack": {
        "title": "Tech Stack",
        "items": {
          "vue": "Vue 3 with Composition API",
          "pinia": "Pinia for state management",
          "tailwind": "Tailwind CSS 4",
          "vite": "Vite 7 build tool",
          "typescript": "TypeScript",
          "zod": "Zod schema validation",
          "workers": "Web Workers for isolated execution"
        }
      },
      "architecture": {
        "title": "Architecture",
        "items": {
          "clientOnly": "Entirely client-side ‚Äî no backend required",
          "noRouter": "Store-driven navigation (no vue-router)",
          "dsl": "DSL-based algorithm creation for safety",
          "persistence": "Versioned localStorage with schema migrations"
        }
      }
    },
    "credits": {
      "title": "Credits & License",
      "aiAssisted": "This project was developed with the assistance of AI tools.",
      "license": "Released under the GNU Affero General Public License v3.0 (AGPL-3.0).",
      "openSource": "Open source on GitHub"
    }
  },
  "algorithms": {
    "tags": {
      "fast": "Fast",
      "modern": "Modern",
      "educational": "Educational",
      "legacy": "Legacy"
    },
    "sfc32": {
      "name": "SFC32",
      "description": "Small Fast Counter - 128-bit state PRNG. Passes PractRand and BigCrush. Excellent quality and speed.",
      "recommended": "General purpose, simulations, games"
    },
    "mulberry32": {
      "name": "Mulberry32",
      "description": "Minimalistic 32-bit state PRNG. Very fast, passes gjrand tests. Period ~4 billion.",
      "recommended": "Quick random numbers when state size matters",
      "warning": "May skip about 1/3 of all 32-bit values"
    },
    "splitmix32": {
      "name": "SplitMix32",
      "description": "Based on MurmurHash3's fmix32 finalizer. 32-bit state, very fast.",
      "recommended": "Seeding other PRNGs, hash-based applications"
    },
    "xorshift32": {
      "name": "Xorshift32",
      "description": "Marsaglia's original 32-bit Xorshift (2003). Simple structure, educational value.",
      "recommended": "Learning PRNG fundamentals",
      "warning": "Fails many modern statistical tests. Not for production use."
    },
    "xoshiro128ss": {
      "name": "xoshiro128**",
      "description": "Modern Xorshift derivative (2018). 128-bit state, fast, good quality.",
      "recommended": "General purpose when xorshift family is preferred",
      "warning": "Has LFSR-related issues in lower bits"
    },
    "lcg": {
      "name": "LCG (Park-Miller)",
      "description": "Linear Congruential Generator with MINSTD parameters. Classic educational PRNG.",
      "recommended": "Learning about PRNG structure and weaknesses",
      "warning": "Fails modern tests quickly. Educational only."
    },
    "simpleCounter": {
      "name": "Simple Counter",
      "description": "The worst possible PRNG - just increments by 1. Completely predictable.",
      "recommended": "Learning what makes a bad PRNG",
      "warning": "Not random at all. For educational comparison only."
    },
    "references": {
      "pracrand": "PractRand",
      "mulberry32_gist": "Original implementation",
      "splitmix_paper": "SplitMix paper",
      "xorshift_paper": "Xorshift RNGs paper",
      "xoshiro_paper": "Scrambled Linear PRNGs paper",
      "lcg_wikipedia": "Wikipedia",
      "park_miller": "Park-Miller paper"
    }
  },
  "dsl": {
    "error": {
      "unknownVariable": "Unknown variable: {variable}",
      "tooManyOperations": "Too many operations per step",
      "outputVariableNotFound": "Output variable not found: {variable}",
      "unknown": "Unknown error"
    },
    "validate": {
      "nameRequired": "Algorithm name is required",
      "stateRequired": "At least one state variable is required",
      "operationRequired": "At least one operation is required",
      "undefinedVariable": "Operation uses undefined state variable: {variable}",
      "outputVariableNotFound": "Output variable not found: {variable}"
    }
  },
  "operationDocs": {
    "title": "Operations Reference",
    "subtitle": "Learn what each operation does",
    "introduction": "These are the building blocks you use to create random number generators. Each operation transforms numbers in a specific way.",
    "whatAreBits": {
      "title": "What are bits?",
      "content": "Computers store numbers as sequences of 0s and 1s called \"bits\". For example, the number 5 is stored as 0101 in binary. Each position represents a power of 2: the rightmost is 1, then 2, then 4, then 8, and so on. Understanding bits helps you see how these operations work!"
    },
    "categories": {
      "arithmetic": "Math Operations",
      "arithmeticDesc": "Basic math like adding and multiplying numbers",
      "bitwise": "Bit Operations",
      "bitwiseDesc": "Operations that work on individual bits (0s and 1s)",
      "shift": "Shift Operations",
      "shiftDesc": "Move bits left or right within a number",
      "rotate": "Rotate Operations",
      "rotateDesc": "Move bits around in a circle (no bits are lost)"
    },
    "operations": {
      "add": {
        "name": "Addition",
        "brief": "Add two numbers together",
        "detailed": "Just like regular math! Add two numbers together. If the result gets too big (over 4 billion), it wraps around back to 0 - like an odometer in a car rolling over.",
        "whyUseful": "Addition mixes numbers well because carrying (like 9+1=10) causes changes to spread across many digits.",
        "example": "5 + 3 = 8",
        "exampleOverflow": "4,294,967,295 + 1 = 0 (wraps around!)"
      },
      "sub": {
        "name": "Subtraction",
        "brief": "Subtract one number from another",
        "detailed": "Regular subtraction. If the result would be negative, it wraps around to a large positive number instead.",
        "whyUseful": "Similar to addition but in reverse. Less common in random generators but still useful.",
        "example": "5 - 3 = 2",
        "exampleOverflow": "0 - 1 = 4,294,967,295 (wraps around!)"
      },
      "mul": {
        "name": "Multiplication",
        "brief": "Multiply two numbers",
        "detailed": "Multiply two numbers together. Like addition, if the result is too big, it wraps around. Multiplication is very powerful for mixing because it affects many bits at once.",
        "whyUseful": "Multiplying scrambles bits very effectively. Many of the best random generators use special multiplication constants.",
        "example": "3 √ó 5 = 15",
        "exampleOverflow": "Large numbers wrap to fit in 32 bits"
      },
      "mod": {
        "name": "Modulo (Remainder)",
        "brief": "Get the remainder after division",
        "detailed": "Divides the first number by the second and gives you the remainder. Like asking \"what's left over?\" For example, 17 √∑ 5 = 3 remainder 2, so 17 mod 5 = 2.",
        "whyUseful": "Keeps numbers within a specific range. For example, n mod 100 always gives a result between 0 and 99.",
        "example": "17 % 5 = 2 (17 = 3√ó5 + 2, remainder is 2)",
        "exampleOverflow": "10 % 3 = 1"
      },
      "xor": {
        "name": "XOR (Exclusive OR)",
        "brief": "Flip bits where inputs differ",
        "detailed": "Compares two numbers bit by bit. If the bits are different, the result is 1. If they're the same, the result is 0. Think of it as \"one or the other, but not both\".",
        "whyUseful": "XOR is magical for random generators! It's reversible (A XOR B XOR B = A), mixes bits without losing information, and is very fast.",
        "example": "0101 XOR 0011 = 0110",
        "visualization": "Bit 1: 0‚â†0? No ‚Üí 0 | Bit 2: 1‚â†0? Yes ‚Üí 1 | Bit 3: 0‚â†1? Yes ‚Üí 1 | Bit 4: 1‚â†1? No ‚Üí 0"
      },
      "and": {
        "name": "AND",
        "brief": "Keep bits that are 1 in both inputs",
        "detailed": "Compares two numbers bit by bit. The result is 1 only if BOTH bits are 1. Think of it as \"both must agree\".",
        "whyUseful": "AND is great for extracting specific bits from a number (called \"masking\"). For example, n AND 255 extracts just the last 8 bits.",
        "example": "0101 AND 0011 = 0001",
        "visualization": "Bit 1: 0 AND 0 = 0 | Bit 2: 1 AND 0 = 0 | Bit 3: 0 AND 1 = 0 | Bit 4: 1 AND 1 = 1"
      },
      "or": {
        "name": "OR",
        "brief": "Set bits that are 1 in either input",
        "detailed": "Compares two numbers bit by bit. The result is 1 if EITHER bit is 1. Think of it as \"at least one says yes\".",
        "whyUseful": "OR is used to combine bits or ensure certain bits are set. Less common in random generators than XOR.",
        "example": "0101 OR 0011 = 0111",
        "visualization": "Bit 1: 0 OR 0 = 0 | Bit 2: 1 OR 0 = 1 | Bit 3: 0 OR 1 = 1 | Bit 4: 1 OR 1 = 1"
      },
      "not": {
        "name": "NOT (Flip All Bits)",
        "brief": "Flip every bit",
        "detailed": "Inverts every bit in the number. All 0s become 1s, and all 1s become 0s. This only needs one input.",
        "whyUseful": "NOT creates the \"opposite\" of a number. Rarely used alone but can be combined with other operations.",
        "example": "NOT 0101 = 1010",
        "visualization": "Every bit flips: 0‚Üí1 and 1‚Üí0"
      },
      "shl": {
        "name": "Shift Left",
        "brief": "Move all bits to the left",
        "detailed": "Moves all bits to the left by a certain number of positions. Empty spaces on the right are filled with 0s. Bits that fall off the left side are lost.",
        "whyUseful": "Shifting left multiplies by powers of 2. Shift left by 1 = multiply by 2. It's also useful for moving bits to different positions.",
        "example": "0001 << 2 = 0100 (shifted 2 positions left)",
        "visualization": "Original: 00000001 ‚Üí After << 2: 00000100"
      },
      "shr": {
        "name": "Shift Right (Signed)",
        "brief": "Move bits right, keeping the sign",
        "detailed": "Moves all bits to the right. The leftmost bit (sign bit) is copied to fill empty spaces. This preserves whether the number is positive or negative.",
        "whyUseful": "Divides by powers of 2 while keeping the sign. Less common in random generators than unsigned shift.",
        "example": "1000 >> 2 = 1110 (sign bit fills in)",
        "visualization": "For negative numbers, 1s fill from the left"
      },
      "ushr": {
        "name": "Shift Right (Unsigned)",
        "brief": "Move bits right, filling with zeros",
        "detailed": "Moves all bits to the right and always fills empty spaces with 0s. This treats the number as positive regardless of the leftmost bit.",
        "whyUseful": "Most random generators use this because they work with bit patterns, not signed numbers. Very common operation!",
        "example": "1000 >>> 2 = 0010 (zeros fill from left)",
        "visualization": "Original: 10000000 ‚Üí After >>> 2: 00100000"
      },
      "rotl": {
        "name": "Rotate Left",
        "brief": "Rotate bits left (they wrap around)",
        "detailed": "Like shift left, but bits that fall off the left side come back on the right side. No information is ever lost - bits just move in a circle!",
        "whyUseful": "Rotation mixes bits excellently without losing any. Many modern random generators use rotation because it's fast and effective.",
        "example": "1001 rotl 1 = 0011 (the leftmost 1 wraps to the right)",
        "visualization": "Bits move in a circle: left side ‚Üí right side"
      },
      "rotr": {
        "name": "Rotate Right",
        "brief": "Rotate bits right (they wrap around)",
        "detailed": "Like shift right, but bits that fall off the right side come back on the left side. Just like rotate left but in the opposite direction.",
        "whyUseful": "Same benefits as rotate left. Combined with XOR and addition, rotation creates very strong mixing.",
        "example": "1001 rotr 1 = 1100 (the rightmost 1 wraps to the left)",
        "visualization": "Bits move in a circle: right side ‚Üí left side"
      }
    },
    "tips": {
      "title": "Tips for Building PRNGs",
      "tip1": "Combine different types of operations (addition + XOR + shift) for better mixing",
      "tip2": "Use specific \"magic numbers\" as constants - they've been tested to work well",
      "tip3": "Make sure every bit gets mixed eventually - don't leave some bits unchanged",
      "tip4": "Test your generator with the Charts and Tests tabs to see if it's random enough"
    },
    "tryIt": "Try it!",
    "learnMore": "Learn more",
    "showDetails": "Show details",
    "hideDetails": "Hide details"
  },
  "learn": {
    "title": "The Mystery of Magic Numbers",
    "subtitle": "Learn how computers create numbers that seem random",
    "resetProgress": "Reset Progress",
    "confirmReset": "Are you sure you want to reset all your learning progress?",
    "completePrerequisites": "Complete previous world to unlock",
    "workshopUnlocked": {
      "title": "Workshop Unlocked!",
      "description": "You've earned access to the full Workshop. Experiment freely!"
    },
    "worlds": {
      "world1": {
        "title": "World 1: Numbers That Remember",
        "description": "Learn about state, memory, and variables",
        "badge": "Number Keeper"
      },
      "world2": {
        "title": "World 2: Secret Recipes",
        "description": "Learn about multiplication, modulo, and combining operations",
        "badge": "Recipe Mixer"
      },
      "world2_5": {
        "title": "World 2.5: Bridge to Bits",
        "description": "Introduction to binary thinking",
        "badge": "Binary Explorer"
      },
      "world3": {
        "title": "World 3: The Dance of Bits",
        "description": "Master binary operations like shift and XOR",
        "badge": "Bit Master"
      },
      "world4": {
        "title": "World 4: Master Builders",
        "description": "Fork and modify real PRNG algorithms",
        "badge": "Randomness Engineer"
      },
      "world5": {
        "title": "World 5: Advanced Lab",
        "description": "Multi-state algorithms and advanced techniques",
        "badge": "Researcher"
      }
    },
    "lessons": {
      "lesson1_1": {
        "title": "The Sleeping Number",
        "objective": "Understand the concept of variable/state",
        "narrative": "Imagine you have a magic box. Inside there's a number - let's call it the STATE. This number is special because it remembers where it is. Every time you peek inside, you see the same number... until you do something to change it. This 'memory' is the foundation of how computers generate numbers that seem random!",
        "bridge": "That number you just revealed (42) is the STATE. But here's the key insight: if we apply a RULE to that number (like 'add 7' or 'multiply by 3'), we get a NEW number. Apply the rule again, get another number. Apply it 100 times... you get a SEQUENCE of 100 numbers! And here's the magic: if two boxes start with the SAME number and use the SAME rule, they'll produce the EXACT SAME sequence!",
        "completion": "You discovered that numbers can be stored!",
        "quiz": {
          "q1": {
            "question": "If two boxes start with the same number, will they always produce the same sequence?",
            "optionA": "No, each box creates its own random numbers",
            "optionB": "Yes, the same starting number always gives the same results",
            "optionC": "It depends on the weather",
            "correct": "Exactly! This is called DETERMINISM - same input always gives same output.",
            "incorrect": "Think about it: if the box follows the same rules and starts the same way..."
          }
        }
      },
      "lesson1_2": {
        "title": "The Magic Seed",
        "objective": "Understand that initial state matters",
        "narrative": "What if you could choose what number the box starts with? That special starting number is called a SEED. Here's the powerful idea: games save the seed so players can replay the exact same 'random' experience! Speedrunners share seeds to compare runs on identical maps. Try different seeds below - notice how the SAME seed always produces the SAME sequence.",
        "reflection": "üîë KEY INSIGHT: Same seed = Same sequence, EVERY time! This is why seeds are so powerful. Game developers save seeds to recreate levels. Players share seeds to compete on identical challenges. The 'random' numbers aren't really random at all - they're completely determined by the seed!",
        "completion": "You learned about seeds! Same seed = same sequence, every time.",
        "quiz": {
          "q1": {
            "question": "Why would a game developer want to save the seed that started a level?",
            "optionA": "To recreate the exact same level later",
            "optionB": "Seeds are pretty to look at",
            "optionC": "It's required by law",
            "correct": "Right! Saving the seed lets you replay the exact same 'random' experience.",
            "incorrect": "Think: if the same seed gives the same results, what could you do with a saved seed?"
          }
        }
      },
      "lesson1_3": {
        "title": "The Boring Counter",
        "objective": "First transformation (simple addition)",
        "narrative": "Now your box can do something: COUNT! Every time you press the button, the number grows.",
        "completion": "This is PREDICTABLE. Is this what real randomness looks like?",
        "quiz": {
          "q1": {
            "question": "Could your friend predict the next number from this counter?",
            "optionA": "Yes, it's always the current number plus 1",
            "optionB": "No, it's impossible to guess",
            "optionC": "Only if they know advanced math",
            "correct": "Exactly! A simple counter is completely PREDICTABLE - terrible for randomness!",
            "incorrect": "Watch the pattern: 1, 2, 3, 4... can you guess what comes next?"
          }
        }
      },
      "lesson1_4": {
        "title": "Where's the Mystery?",
        "objective": "Identify that simple addition is NOT random",
        "narrative": "Let's compare two different number generators side by side...",
        "hint": "üëÄ WHAT TO LOOK FOR: In the plots below, watch for PATTERNS. A predictable generator shows a clear diagonal line (each number relates to the next in an obvious way). A good generator shows scattered dots with no visible pattern. Which one would you want for a dice game?",
        "completion": "A simple counter is predictable. We need something better!",
        "quiz": {
          "q1": {
            "question": "Why can't we use a simple counter for a dice game?",
            "optionA": "Counters are too slow",
            "optionB": "Counters only go up to 6",
            "optionC": "Players could easily predict the next roll",
            "correct": "Right! Predictability is the enemy of fair games. We need unpredictable numbers!",
            "incorrect": "Think about what happens if your opponent knows the pattern..."
          }
        }
      },
      "lesson2_1": {
        "title": "Explosive Multiplication",
        "objective": "See how multiplication creates dramatic changes",
        "narrative": "Adding is like walking. Multiplying is like... JUMPING!",
        "completion": "You discovered that multiplication makes numbers grow much faster!",
        "quiz": {
          "q1": {
            "question": "Why does multiplication create more unpredictable patterns than addition?",
            "optionA": "Multiplication makes bigger jumps - small changes have dramatic effects",
            "optionB": "Addition is actually more unpredictable",
            "optionC": "They're equally predictable",
            "correct": "Exactly! Multiplication amplifies changes dramatically. Going from 5 to 6 (√ó1) is small, but 5√ó3=15 to 6√ó3=18 - the gap grows!",
            "incorrect": "Think about it: adding 1 always adds 1. But multiplying by 3 turns a +1 change into a +3 change!"
          }
        }
      },
      "lesson2_2": {
        "title": "The Giant Number Problem",
        "objective": "Understand overflow and memory limits",
        "narrative": "What happens if we multiply so many times that the number doesn't fit anymore? Computers store numbers in fixed-size boxes. When a number gets too big, it OVERFLOWS and wraps back around - just like a car odometer rolling over from 999,999 to 000,000! In our demo, we'll use a small box (0-255) to see this clearly. Real PRNGs use 32-bit boxes (0 to 4 billion), but the principle is the same. This 'accident' is actually USEFUL for PRNGs because it scrambles numbers in surprising ways.",
        "completion": "Computers have fixed-size boxes. When they overflow, they wrap around like a clock!",
        "quiz": {
          "q1": {
            "question": "The number overflowed and wrapped around! Is this a bug or a feature for PRNGs?",
            "optionA": "A bug - we should fix it",
            "optionB": "A feature - it helps create unpredictable patterns!",
            "optionC": "It doesn't matter - overflow never happens in real programs",
            "correct": "Exactly! Overflow is USEFUL because it scrambles the number in unexpected ways.",
            "incorrect": "Think: does the wrapping make numbers more or less predictable?"
          }
        }
      },
      "lesson2_3": {
        "title": "The Cutter (Modulo)",
        "objective": "Understand the modulo operator",
        "narrative": "What if we want a number that never goes past 10? We use THE CUTTER.",
        "primer": "Here's a secret: PRNG designers love PRIME numbers (like 7, 13, 31, 127). Why? When you use mod 10, patterns like 0-10-20-30 all land on the same spot. But with mod 7 or mod 13, numbers spread out more evenly - primes have no common factors to create shortcuts! This creates longer cycles and less predictable patterns.",
        "completion": "The modulo operator cuts numbers down to size!",
        "quiz": {
          "q1": {
            "question": "What does 17 mod 5 equal?",
            "optionA": "2 - it's the remainder after dividing 17 by 5",
            "optionB": "3 - because 17 divided by 5 is about 3.4",
            "optionC": "12 - because 17 minus 5 is 12",
            "correct": "Correct! 5 goes into 17 three times (5√ó3=15), leaving a remainder of 2.",
            "incorrect": "Think: how many times does 5 fit into 17? What's left over?"
          }
        }
      },
      "lesson2_4": {
        "title": "Mixing Recipes",
        "objective": "Combine operations (multiply + add)",
        "narrative": "What happens if we use TWO rules at the same time?",
        "warning": "‚ö†Ô∏è BEWARE of recipe-breaking operations! Some combinations destroy all randomness. For example: any number √ó 0 = 0. Once you hit zero, you're stuck forever! Can you spot the dangerous operation in the next quiz?",
        "completion": "Combining operations creates more interesting patterns!",
        "quiz": {
          "q1": {
            "question": "DEBUG: This recipe produces 0, 0, 0, 0... What's wrong?\n\nstate = state √ó 2\nstate = state √ó 0",
            "optionA": "The multiplication by 2 is wrong",
            "optionB": "Multiplying by 0 destroys everything!",
            "optionC": "We need to add more steps",
            "correct": "Exactly! Anything times 0 equals 0. One bad operation can ruin everything!",
            "incorrect": "What happens when you multiply ANY number by 0?",
            "hint1": "Try calculating: 5 √ó 2 √ó 0 = ?"
          }
        }
      },
      "lesson2_5": {
        "title": "LCG: Your First Real Generator",
        "objective": "Explore a real linear generator through forking",
        "narrative": "Scientists discovered a special recipe called LCG. Let's modify a real one!",
        "formula": "üìê THE LCG FORMULA: state = (state √ó multiplier + increment) mod modulus. That's it! Three numbers (multiplier, increment, modulus) define the entire algorithm. Scientists tested MILLIONS of combinations to find ones that produce good randomness. The multiplier 48271 you'll see below was proven to work well through mathematical analysis.",
        "completion": "You've explored a real PRNG algorithm!",
        "quiz": {
          "q1": {
            "question": "Try changing the LCG multiplier from 48271 to just 2. What happens to the output quality?",
            "optionA": "The output looks the same - any multiplier works fine",
            "optionB": "The output gets worse - the original number was chosen carefully by mathematicians",
            "optionC": "The output gets better - smaller numbers are more random",
            "correct": "Exactly! Those specific constants (like 48271) were tested extensively. Random-looking numbers often work better than simple ones!",
            "incorrect": "Look at the histogram and correlation plot after changing the multiplier. Do the patterns look random?"
          }
        }
      },
      "lesson2_5_1": {
        "title": "The Guessing Game",
        "objective": "Discover how yes/no questions find numbers fast",
        "narrative": "Let's play a game! I'm thinking of a number between 1 and 16. How many questions do you need to guess it?",
        "binaryConnection": "üîó THE BINARY CONNECTION: You needed exactly 4 questions for 16 numbers. That's not a coincidence! Each YES/NO question is like a BINARY DIGIT (bit): 4 questions = 4 bits = 16 possible values. This is how computers represent numbers - with switches that are either ON (1) or OFF (0). 8 bits = 256 values, 32 bits = over 4 billion!",
        "completion": "With just yes/no questions, you can find any number! This is the foundation of binary thinking.",
        "quiz": {
          "q1": {
            "question": "To find a number from 1-16, which strategy is faster?",
            "optionA": "Ask 'Is it 1? Is it 2? Is it 3?...' one by one (up to 16 questions)",
            "optionB": "Ask 'Is it greater than 8?' then keep halving (only 4 questions needed)",
            "optionC": "Just guess randomly",
            "correct": "Exactly! Halving is much faster: 16‚Üí8‚Üí4‚Üí2‚Üí1 in just 4 steps!",
            "incorrect": "Think about it: checking one by one could take 16 tries. How many halvings to go from 16 to 1?"
          }
        }
      },
      "lesson2_5_2": {
        "title": "Light Switch Numbers",
        "objective": "Introduce 4-bit binary representation",
        "narrative": "Imagine 4 light switches. Each can be ON or OFF. Together, they make a number!",
        "insight": "üéØ You just explored ALL 16 possible values with only 4 switches! The formula is simple: 2‚Å¥ = 16. Each switch doubles the possibilities: 1 switch = 2 values, 2 switches = 4 values, 3 switches = 8 values, 4 switches = 16 values. This exponential growth is the secret power of binary!",
        "completion": "You can represent any number from 0 to 15 with just 4 switches!",
        "quiz": {
          "q1": {
            "question": "In a 4-bit number, which bit position has the BIGGEST impact when flipped?",
            "optionA": "The leftmost bit (worth 8) - it changes the number the most!",
            "optionB": "The rightmost bit (worth 1) - it's the 'ones' place",
            "optionC": "All bits have equal impact",
            "correct": "Right! The leftmost bit is worth 8, so flipping it causes the biggest change!",
            "incorrect": "Think about place values: in 1111, the left bit is worth 8, the right is worth 1."
          }
        }
      },
      "lesson2_5_3": {
        "title": "More Switches, Bigger Numbers",
        "objective": "Expand to 8 bits, preview 32 bits",
        "narrative": "What if we had MORE switches? We could make BIGGER numbers!",
        "primer": "Here's the power of bits: 8 bits = 256 possibilities, 16 bits = 65,536, and 32 bits = over 4 BILLION! Each extra bit DOUBLES the possibilities. Real PRNGs use 32 or 64 bits because they need HUGE numbers of possible states - so patterns don't repeat for billions of steps!",
        "completion": "You now understand how computers see numbers. Time to learn how to DANCE with bits!",
        "quiz": {
          "q1": {
            "question": "Each additional bit DOUBLES the number of possibilities. If 4 bits = 16 values, what do 8 bits give you?",
            "optionA": "32 values (16 + 16)",
            "optionB": "256 values (16 √ó 16, or 2‚Å∏)",
            "optionC": "64 values (16 √ó 4)",
            "correct": "Exactly! Each bit doubles: 4 bits = 16, 5 bits = 32, 6 bits = 64, 7 bits = 128, 8 bits = 256!",
            "incorrect": "Remember: each new bit DOUBLES the possibilities, not adds to them."
          }
        }
      },
      "lesson3_1": {
        "title": "The Shift (Moving Bits)",
        "objective": "Understand bit shifting",
        "narrative": "What happens if we PUSH all the switches to the left?",
        "completion": "Shifting left is like multiplying by 2 - but faster for computers!",
        "quiz": {
          "q1": {
            "question": "Why might bit shifting be BETTER than multiplication for a PRNG?",
            "optionA": "Shifting is slower but more accurate",
            "optionB": "Shifting is extremely fast - computers do it in one clock cycle",
            "optionC": "Shifting makes prettier patterns",
            "correct": "Exactly! Speed matters for PRNGs - they might be called millions of times!",
            "incorrect": "Think about what makes a good PRNG: quality AND speed."
          }
        }
      },
      "lesson3_2": {
        "title": "XOR: The Difference Detector",
        "objective": "Understand the XOR operation",
        "narrative": "XOR is a special rule: it compares two bits and checks if they're DIFFERENT.",
        "completion": "XOR has a magic property: doing it twice brings you back!",
        "quiz": {
          "q1": {
            "question": "XOR twice with the same number returns the original. How could this be useful?",
            "optionA": "It's not useful at all",
            "optionB": "You can use it to 'hide' and 'reveal' data - like simple encryption!",
            "optionC": "It only works with prime numbers",
            "correct": "Right! XOR is used in encryption, checksums, and mixing bits in PRNGs.",
            "incorrect": "Think: if A XOR B XOR B = A, what can you do with that property?"
          }
        }
      },
      "lesson3_3": {
        "title": "The Perfect Mix",
        "objective": "Combine shift and XOR",
        "narrative": "Number wizards discovered something: if you shift AND mix with XOR, the numbers DANCE!",
        "completion": "A small change in input creates a BIG change in output!",
        "quiz": {
          "q1": {
            "question": "Why do we combine shift and XOR?",
            "optionA": "It makes numbers smaller",
            "optionB": "It creates more unpredictable changes",
            "optionC": "It makes the code run faster",
            "correct": "Exactly! The combination scrambles the bits effectively.",
            "incorrect": "Think about how each operation affects the pattern."
          }
        }
      },
      "lesson3_4": {
        "title": "Xorshift: Your Second Real Generator",
        "objective": "Explore Xorshift through forking",
        "narrative": "You've learned the building blocks: shifting moves bits, XOR mixes them. Now let's see them working together in a REAL generator called Xorshift. This algorithm was invented by George Marsaglia in 2003 and uses ONLY shifts and XORs - no multiplication needed! Try changing the shift amounts and watch what happens to the output quality.",
        "comparisonIntro": "Now that you've explored Xorshift, let's compare it directly with the LCG you learned earlier. Watch the correlation plots side by side - which algorithm produces more scattered (random-looking) dots?",
        "completion": "You've mastered the most powerful operations. Time to build PROFESSIONAL generators!",
        "quiz": {
          "q1": {
            "question": "What makes Xorshift special compared to LCG?",
            "optionA": "It uses multiplication which is faster",
            "optionB": "It only uses shift and XOR operations - no multiplication needed!",
            "optionC": "It produces truly random numbers from the hardware",
            "correct": "Exactly! Xorshift achieves good randomness using only simple bit operations, making it very fast.",
            "incorrect": "Think about what operations Xorshift uses. Did you see any multiplication?"
          }
        }
      },
      "lesson4_1": {
        "title": "Mulberry32: The Industrial Machine",
        "objective": "Explore a real production algorithm through forking",
        "narrative": "Welcome to Mulberry32 - a generator actually used in games and applications! Notice how it combines everything we've learned: addition creates chaos, multiplication scrambles thoroughly, and XOR with shifted copies mixes the bits. The 'magic constant' 0x6D2B79F5 was found through millions of tests. Let's see what happens when you change it!",
        "magicConstants": "üîÆ MAGIC CONSTANTS EXPLAINED: Why 0x6D2B79F5? These weird hex numbers create what's called the 'avalanche effect' - changing ONE input bit causes roughly HALF of the output bits to flip. Researchers test millions of candidates and keep only those that: 1Ô∏è‚É£ Pass statistical tests 2Ô∏è‚É£ Have good bit-mixing properties 3Ô∏è‚É£ Don't create short cycles. Try changing it to 0x00000001 below and watch the quality collapse!",
        "completion": "You've analyzed a professional-grade PRNG!",
        "quiz": {
          "q1": {
            "question": "Mulberry32 uses 'magic constants' like 0x6D2B79F5. Try changing it to 0x00000001. What happens?",
            "optionA": "Nothing changes - constants don't matter",
            "optionB": "Quality gets worse - those constants were chosen through extensive testing",
            "optionC": "Quality improves",
            "correct": "Exactly! Those weird hex numbers were carefully tested - changing them breaks quality.",
            "incorrect": "Try it! Change the constant and watch the quality tests."
          }
        }
      },
      "lesson4_2": {
        "title": "The Quality Lab",
        "objective": "Use the full test suite",
        "narrative": "Scientists use special tests to check if numbers are truly random-looking. Let's use them!",
        "testTypes": "üìä UNDERSTANDING THE TESTS: **Mean Test** - checks if the average is close to 0.5 (the middle). A biased generator might favor high or low numbers. **Chi-Square Test** - checks if numbers spread evenly across all values. Even with a good average, numbers might cluster in certain ranges. **Correlation Test** - checks if consecutive numbers are related. A bad generator might have patterns like 'high always follows low'. You need to pass ALL tests to be considered random!",
        "completion": "You now know how to evaluate any generator scientifically!",
        "quiz": {
          "q1": {
            "question": "Algorithm A passes the mean test but FAILS chi-square. What does this tell you?",
            "optionA": "The algorithm is perfect",
            "optionB": "The average is right, but numbers cluster in certain ranges instead of spreading evenly",
            "optionC": "The tests are broken and should be ignored",
            "correct": "Right! Each test catches different problems. You need to pass ALL tests!",
            "incorrect": "Mean test checks average. Chi-square checks distribution. What if average is good but distribution is clumpy?"
          }
        }
      },
      "lesson4_3": {
        "title": "The Designer's Challenge",
        "objective": "Create your own generator",
        "narrative": "Time to put everything together! You've learned about addition, multiplication, XOR, and shifts. Now design YOUR OWN generator!",
        "guidance": "üõ†Ô∏è DESIGN TIPS: Start simple and build up! 1Ô∏è‚É£ Begin with just 2 operations (e.g., multiply then XOR) 2Ô∏è‚É£ Use odd multipliers (3, 5, 7) - even numbers create patterns 3Ô∏è‚É£ Add shift operations to spread changes across bits 4Ô∏è‚É£ Test with the visualizations - look for scattered patterns, not lines 5Ô∏è‚É£ If output looks bad, try different constants. Good designs often use prime-ish numbers!",
        "completion": "You've become a PRNG designer!",
        "quiz": {
          "q1": {
            "question": "When designing a PRNG, what's the most important thing to consider FIRST?",
            "optionA": "Making it as complex as possible with many operations",
            "optionB": "Ensuring each operation actually improves mixing/randomness quality",
            "optionC": "Using only the newest, trendiest operations",
            "correct": "Exactly! Each operation should have a purpose. More complexity doesn't mean better quality!",
            "incorrect": "Think about what you learned: some simple generators beat complex ones. Why?"
          }
        }
      },
      "lesson4_4": {
        "title": "The Generator Gallery",
        "objective": "Compare all learned algorithms",
        "narrative": "Let's see how all the generators we've learned compare to each other.",
        "reflection": "üèÜ Look how far you've come! From a simple counter that just added 1, to sophisticated algorithms using multiplication, XOR, and bit shifts. You've seen how each technique improves quality: counters are predictable, LCG adds mixing, Xorshift uses fast bit operations, and Mulberry32 combines everything into a production-ready generator. You're now ready to design your own!",
        "completion": "Congratulations! You understand how computers create numbers that seem random. Workshop unlocked!",
        "quiz": {
          "q1": {
            "question": "Rank these for a GAME: Counter, LCG, Xorshift, Mulberry32. Which matters most?",
            "optionA": "Speed only - games need fast generators",
            "optionB": "Quality AND speed - games need unpredictable numbers that don't slow things down",
            "optionC": "Quality only - speed doesn't matter for modern computers",
            "correct": "Right! Games need both. Mulberry32/Xorshift win because they're fast AND high quality.",
            "incorrect": "A slow generator hurts performance. A predictable one lets players cheat. You need both!"
          }
        }
      },
      "lesson5_1": {
        "title": "Multi-State Algorithms",
        "objective": "Understand algorithms with multiple state variables",
        "narrative": "So far, all our generators used ONE state variable. But what if we used MULTIPLE variables that interact with each other? This is like having four dancers instead of one - their interactions create patterns that are much harder to predict. SFC32 uses 4 variables (a, b, c, counter) that constantly mix together, creating 128 bits of state instead of just 32!",
        "completion": "Multiple state variables make algorithms harder to predict!",
        "quiz": {
          "q1": {
            "question": "SFC32 uses 4 state variables that interact. Why is this harder to crack than 1 variable?",
            "optionA": "It's actually easier with more variables",
            "optionB": "4 interacting variables create exponentially more possible states and longer periods",
            "optionC": "More variables just means more memory usage",
            "correct": "Exactly! 4 √ó 32-bit variables = 128 bits of state = astronomically more combinations!",
            "incorrect": "Think about combinations: 1 variable has N states, but 4 have N√óN√óN√óN states."
          }
        }
      },
      "lesson5_2": {
        "title": "xoshiro128**: The Modern One",
        "objective": "Explore modern algorithms",
        "narrative": "Meet xoshiro128** (pronounced 'zoh-shee-roh'), created in 2018 by Blackman and Vigna. What makes it state-of-the-art? It uses ROTATION instead of just shifts - rotation preserves ALL bits by wrapping them around instead of losing them off the edge. Combined with 128 bits of state across 4 variables, it passes the most rigorous test suites while being incredibly fast. The '**' in the name refers to its scrambler function that further improves output quality.",
        "algorithmIntro": "Now let's see rotation in action inside a real algorithm! xoshiro128** uses rotation along with 4 state variables that interact in complex ways. Try modifying the rotation amounts and watch how it affects the output quality.",
        "completion": "You've explored one of the most modern PRNG algorithms!",
        "quiz": {
          "q1": {
            "question": "xoshiro uses ROTATION instead of just shifts. Why is rotation better?",
            "optionA": "Rotation preserves ALL bits - nothing is lost. Shifts lose bits off the edge!",
            "optionB": "Rotation is slower but prettier",
            "optionC": "Rotation and shifts work exactly the same way",
            "correct": "Right! Rotation wraps bits around instead of discarding them, preserving information.",
            "incorrect": "When you shift, bits fall off one end. Where do they go in rotation?"
          }
        }
      },
      "lesson5_3": {
        "title": "Advanced Test Interpretation",
        "objective": "Deeply understand quality test results",
        "narrative": "Let's learn what each test actually measures and what failures really mean.",
        "realWorld": " THE REAL-WORLD GAP: Our tests use ~1,000 samples. But games might call a PRNG millions of times! A generator can pass simple tests but still show patterns after billions of outputs. That's why professionals use TestU01 and PractRand - they run TRILLIONS of tests. If your game seems 'unlucky' despite passing basic tests, the PRNG might have hidden weaknesses that only show up at scale.",
        "completion": "Now you can read test results like a true cryptographer!",
        "quiz": {
          "q1": {
            "question": "A generator passes all our tests but fails in a real game (players notice patterns). What's missing?",
            "optionA": "Nothing - the tests must be wrong",
            "optionB": "Our tests are basic. Real applications need longer sequences and stricter tests!",
            "optionC": "The game is broken",
            "correct": "Right! Basic tests catch obvious flaws, but professional use needs TestU01, PractRand, etc.",
            "incorrect": "Our tests use ~1000 samples. What if patterns only appear after millions?"
          }
        }
      },
      "lesson5_4": {
        "title": "Your Final Project",
        "objective": "Create an original generator and document it",
        "narrative": "You've traveled from simple counters to multi-state algorithms. You understand shifts, XOR, multiplication, and how they mix bits. Now it's YOUR turn to design a complete PRNG from scratch! Think about: What operations will you use? What constants? How will you ensure good mixing? Document your choices and test your creation!",
        "rubric": "üéØ SUCCESS CRITERIA for your algorithm: 1Ô∏è‚É£ Use at least 3 different operations (add, multiply, xor, shift, etc.) 2Ô∏è‚É£ Avoid 'killer' operations like multiply by 0 or add 0 3Ô∏è‚É£ Try to pass the mean test (numbers should average around 0.5) 4Ô∏è‚É£ Experiment with different constants - bigger primes often work better! Don't worry about making it perfect - the goal is to UNDERSTAND how the pieces work together.",
        "completion": "üèÜ Congratulations! You've completed the advanced course and created your own documented algorithm!",
        "quiz": {
          "q1": {
            "question": "Reflecting on your journey: What's the MOST important lesson about PRNGs?",
            "optionA": "The more operations, the better the generator",
            "optionB": "Quality comes from understanding how operations mix bits, not from complexity alone",
            "optionC": "Real randomness is impossible, so it doesn't matter what we use",
            "correct": "Exactly! You've learned that thoughtful design beats blind complexity. That's the mark of a true engineer!",
            "incorrect": "Think back: which generators performed best? Were they the most complex, or the most thoughtfully designed?"
          }
        }
      }
    },
    "microTeaching": {
      "counting": {
        "concept": "Counting",
        "content": "Count the apples: üçéüçéüçéüçéüçé = ?",
        "insight": "Addition means counting up!"
      },
      "multiplication": {
        "concept": "Multiplication",
        "content": "Before we jump, let's learn what multiplication means!",
        "insight": "Multiplication is repeated addition, but FASTER!"
      },
      "remainder": {
        "concept": "Remainders",
        "content": "Let's learn about leftovers! 7 candies for 3 friends...",
        "insight": "The remainder is what's left after dividing evenly!"
      },
      "xor": {
        "concept": "XOR (Exclusive OR)",
        "content": "XOR compares two bits: if they're DIFFERENT, result is 1. If SAME, result is 0.",
        "insight": "Different? ON. Same? OFF. It's like a difference detector!"
      },
      "shift": {
        "concept": "Bit Shifting",
        "content": "Moving all bits left or right, like sliding tiles on a board.",
        "insight": "Shift left = multiply by 2. Shift right = divide by 2!"
      },
      "shiftDemo": {
        "value": "Number",
        "amount": "Shift by",
        "left": "‚Üê Left",
        "right": "‚Üí Right"
      },
      "xorDemo": {
        "valueA": "Value A",
        "valueB": "Value B",
        "random": "Random",
        "explanation": "XOR: If bits are different ‚Üí 1. If bits are same ‚Üí 0."
      },
      "binary": {
        "concept": "Binary Numbers",
        "content": "Computers use just ON and OFF (1 and 0) to represent all numbers.",
        "insight": "With just 8 switches, you can represent 256 different numbers!"
      },
      "overflow": {
        "concept": "Memory Limits",
        "content": "Computers store numbers in fixed-size boxes. What happens when a number gets too big to fit?",
        "insight": "When a number overflows, it wraps around like an odometer going from 999,999 to 000,000!"
      },
      "multiState": {
        "concept": "Multiple Variables",
        "content": "What if instead of ONE dancer, we had FOUR dancers moving together? Their interactions would be much harder to predict!",
        "insight": "Multiple state variables interact and mix together, creating patterns that are much harder to crack!"
      },
      "shiftXorCombo": {
        "concept": "The Power Combo",
        "content": "Shift MOVES bits to new positions. XOR MIXES bits together. What happens when you do BOTH? Each bit affects multiple positions, creating a cascade of changes!",
        "insight": "Shift + XOR = Avalanche Effect. Change one bit and watch MANY bits flip. This is the secret sauce of fast PRNGs!"
      },
      "xorshift": {
        "concept": "The Xorshift Algorithm",
        "content": "George Marsaglia discovered in 2003 that combining just THREE operations (shift left, shift right, XOR) in the right order creates surprisingly good randomness. No multiplication needed!",
        "insight": "Xorshift proves that SIMPLE operations combined cleverly can rival complex algorithms. The magic is in the specific shift amounts!"
      },
      "binarySearch": {
        "concept": "Divide and Conquer",
        "content": "Imagine finding a number between 1-100. You could check 1, 2, 3... Or ask: 'Is it more than 50?' Each yes/no question cuts possibilities in HALF!",
        "insight": "With yes/no questions, you need only 7 guesses for 1-100. That's the power of halving!"
      },
      "avalanche": {
        "concept": "The Avalanche Effect",
        "content": "Good PRNGs have a special property: changing just ONE input bit should flip roughly HALF of the output bits. Like a tiny snowball triggering an avalanche!",
        "insight": "Magic constants like 0x6D2B79F5 were chosen because they maximize this avalanche effect!"
      },
      "rotation": {
        "concept": "Bit Rotation",
        "content": "Shifting loses bits off the edge. But ROTATION wraps them around! Bits that fall off one side reappear on the other.",
        "insight": "Rotation preserves ALL information. No bits are ever lost, making it perfect for PRNGs!"
      },
      "testInterpretation": {
        "concept": "Reading Test Results",
        "content": "Quality tests each check something different. Mean checks average. Chi-square checks distribution. Correlation checks patterns. A generator must pass ALL of them!",
        "insight": "Failing one test reveals the generator's weakness. Each test is like a detective looking for a different clue!"
      }
    },
    "microTeachingLabel": "Quick Lesson",
    "badges": {
      "collection": "Your Badges",
      "earnedOn": "Earned on {date}",
      "numberKeeper": {
        "name": "Number Keeper",
        "alt": "Number Keeper badge - A purple medal with a box containing the number 42",
        "description": "You discovered that numbers can be stored!"
      },
      "recipeMixer": {
        "name": "Recipe Mixer",
        "alt": "Recipe Mixer badge - An orange medal with a mixing bowl and math symbols",
        "description": "You learned to combine operations to create number recipes!"
      },
      "binaryExplorer": {
        "name": "Binary Explorer",
        "alt": "Binary Explorer badge - A green medal with binary digits and toggle switches",
        "description": "You understand how computers see numbers as bits!"
      },
      "bitMaster": {
        "name": "Bit Master",
        "alt": "Bit Master badge - A blue medal with XOR circles and shift arrows",
        "description": "You mastered the dance of bits with XOR and shifts!"
      },
      "randomnessEngineer": {
        "name": "Randomness Engineer",
        "alt": "Randomness Engineer badge - An amber medal with a gear and wrench",
        "description": "You can build and test professional random number generators!"
      },
      "researcher": {
        "name": "Researcher",
        "alt": "Researcher badge - A gold medal with a magnifying glass, chart, and document",
        "description": "You've mastered advanced algorithms and completed the full course!"
      }
    },
    "operationTrace": {
      "title": "Step-by-Step Trace"
    },
    "comparison": {
      "title": "Algorithm Comparison",
      "meanTest": "Mean Test",
      "varianceTest": "Variance Test",
      "score": "Quality Score"
    },
    "worldLesson": "World {world} ¬∑ Lesson {lesson}",
    "continue": "Continue",
    "previous": "Previous",
    "finish": "Finish",
    "checkAnswer": "Check Answer",
    "nextQuestion": "Next Question",
    "enterAnswer": "Enter your answer",
    "activities": {
      "wakeUp": "Wake up the number",
      "enterNumber": "Enter a number...",
      "yourNumber": "That's YOUR special number: {number}!",
      "seed": "Seed",
      "currentNumber": "Current number",
      "nextNumber": "Next number",
      "reset": "Reset",
      "counter": "Simple Counter",
      "counterDesc": "Just adds 1 each time (predictable!)",
      "professional": "Professional Generator",
      "algorithmDesc": "Uses mathematical mixing",
      "stepBoth": "Step Both",
      "comparisonIntro": "Compare a simple counter with a real PRNG algorithm. Notice the pattern difference!",
      "comparisonHint": "The counter shows a diagonal line (predictable). Good PRNGs show scattered dots (unpredictable).",
      "addVsMultiply": {
        "intro": "Compare how ADDITION vs MULTIPLICATION affect number patterns!",
        "multiplier": "Multiplier",
        "addTitle": "Addition Only",
        "addFormula": "state = state + {n}",
        "mulTitle": "Multiplication",
        "mulFormula": "state = state √ó {n}",
        "step": "Step Both",
        "runMany": "Run 20 Steps",
        "hint": "Notice how addition creates a steady climb, while multiplication jumps around more dramatically!"
      },
      "overflowExplanation": "When we multiply past {max}, the number wraps around!",
      "multiply": "Multiply √ó{n}",
      "forkExplore": "Explore this algorithm by modifying its constants and observing the results.",
      "tryThis": "Try this experiment:",
      "forkExploreAlgorithm": "Algorithm:",
      "forkExploreHint": "Click 'Edit Constants' above to modify values. Watch how changes affect the output patterns!",
      "forkExploreHintLcg": "üí° Try this: Change the 'mul const' from 48271 to just 2. Notice how the correlation plot changes from scattered to diagonal lines!",
      "forkExploreHintXorshift": "üí° Try this: Change one of the shift amounts to 0 or 32. Watch how it breaks the bit mixing and creates visible patterns!",
      "forkExploreHintMulberry": "üí° Try this: Change 0x6D2B79F5 to 0x00000001. The magic constant was carefully chosen - see what happens without it!",
      "forkExploreHintMultiState": "üí° This algorithm uses 4 variables working together. Try changing one constant and watch how it affects all state values!",
      "algorithmExplorer": {
        "state": "Current State",
        "output": "Output",
        "step": "Step",
        "timeSeries": "Output Over Time",
        "correlation": "Correlation Plot",
        "histogram": "Distribution",
        "binaryView": "Binary View",
        "steps": "{count} steps generated",
        "constants": "Algorithm Constants",
        "editConstants": "Edit Constants",
        "doneEditing": "Done",
        "editHint": "Change values and see how it affects the output. Use hex (0x...) for large numbers.",
        "modified": "modified",
        "multiStateInfo": "These variables interact with each other every step",
        "totalStateBits": "{bits} bits of total state = astronomically more combinations!"
      },
      "qualityLab": {
        "title": "Quality Testing Lab",
        "intro": "Run tests on different algorithms to see which ones produce better random numbers.",
        "runTests": "Run Tests",
        "comparing": "Comparing algorithms...",
        "testMean": "Mean Test",
        "testVariance": "Variance Test",
        "testChiSquare": "Chi-Square Test",
        "passed": "PASS",
        "failed": "FAIL"
      },
      "designerChallenge": {
        "title": "Design Challenge",
        "intro": "Create your own generator that passes all the tests!",
        "challenge1": "Pass the histogram test",
        "challenge2": "Use 5 or fewer operations",
        "challenge3": "Pass all quality tests",
        "completed": "Challenge completed!",
        "tryAgain": "Keep trying!"
      },
      "testInterpretation": {
        "title": "Understanding Test Results",
        "intro": "Diagnose what's wrong with these generators based on their test results!",
        "reference": "üìñ Test Reference Guide (click to expand)",
        "meanExplain": "Checks if numbers average to 0.5 (the middle of 0-1 range).",
        "varianceExplain": "Measures how spread out your numbers are.",
        "chiSquareExplain": "Checks if numbers are evenly distributed across all ranges.",
        "scenario": "Scenario {n}",
        "question": "What's likely wrong with this generator?",
        "options": {
          "clumpy": "Numbers cluster in certain ranges instead of spreading evenly",
          "biased": "Numbers tend toward high or low values (not centered)",
          "tooNarrow": "Numbers don't spread out enough (too close together)",
          "perfect": "Nothing - the generator is working fine"
        },
        "explanations": {
          "clumpy": "Chi-Square failure means uneven distribution - some ranges get too many numbers, others too few.",
          "biased": "Mean failure indicates the average isn't centered at 0.5, so numbers lean high or low.",
          "tooNarrow": "Variance failure means numbers cluster too tightly around the mean instead of spreading out."
        },
        "correct": "Correct! You diagnosed it right.",
        "incorrect": "Not quite. Look at which test failed and what it measures.",
        "nextScenario": "Next Scenario",
        "allComplete": "Excellent Work!",
        "summary": "You can now interpret test results like a real PRNG engineer!",
        "tryAgain": "Practice Again"
      },
      "finalProject": {
        "title": "Your Final Project",
        "intro": "Design and document your own PRNG algorithm!",
        "buildAlgorithm": "Build your algorithm by choosing operations:",
        "qualityScore": "Quality Score",
        "steps": "{count} steps generated"
      },
      "seedDemo": {
        "tryPresets": "Try these preset seeds:",
        "orTryOwn": "Or try your own seed:",
        "enterSeed": "Enter seed",
        "try": "Try",
        "seedValue": "Seed",
        "produces": "produces this sequence:",
        "hint": "Same seed = same sequence. Different seed = different sequence!"
      },
      "determinismDemo": {
        "title": "Two Boxes, Same Seed",
        "intro": "Watch what happens when two number generators start with the SAME seed and follow the SAME rules.",
        "boxA": "Box A",
        "boxB": "Box B",
        "stepBoth": "Step Both",
        "identical": "‚úì Both boxes produce the EXACT SAME numbers!",
        "different": "The sequences are different",
        "hint": "Try different seeds - as long as both boxes start the same, they'll always match!"
      },
      "binaryGame": {
        "thinkOfNumber": "Think of a number between 1 and 16. I'll find it with just yes/no questions!",
        "range": "Pick any number from {min} to {max}",
        "question": "Is your number greater than {mid}?",
        "yes": "Yes",
        "no": "No",
        "found": "Your number is {number}!",
        "guessCount": "Found it in just {count} questions!",
        "playAgain": "Play Again",
        "history": "Questions asked:"
      },
      "shiftDemo": {
        "current": "Current Value",
        "shiftBy": "Shift by:",
        "shiftLeft": "Shift Left",
        "shiftRight": "Shift Right",
        "history": "Shift History"
      },
      "xorExperiment": {
        "intro": "Try different values for A and B. Watch how XOR compares each bit!",
        "result": "A XOR B =",
        "hint": "Notice: when bits are DIFFERENT ‚Üí 1, when SAME ‚Üí 0",
        "reversibilityTitle": "‚ú® The Magic Property: XOR is Reversible!",
        "backToA": "Back to A!",
        "reversibilityHint": "XOR the result with B again, and you get back the original A! This is why XOR is used in encryption."
      },
      "shiftXor": {
        "current": "Current State",
        "formula": "Each step: state ^= state << 7; state ^= state >>> 5",
        "step": "Step"
      },
      "rotationVsShift": {
        "title": "Rotation vs Shift: Why Rotation Wins",
        "value": "Number",
        "amount": "Move by",
        "random": "Random",
        "original": "Original Value",
        "shiftLeft": "‚Üê Shift Left",
        "rotateLeft": "‚Üª Rotate Left",
        "bitsLost": "Bits fall off the edge!",
        "bitsPreserved": "Bits wrap around!",
        "lost": "Lost forever",
        "wrapped": "Came back",
        "explanation": "Shift loses bits that fall off the edge. Rotation wraps them around - no information is ever lost! That's why modern PRNGs prefer rotation."
      },
      "comparativeTable": {
        "title": "Algorithm Comparison Summary",
        "algorithm": "Algorithm",
        "mean": "Mean",
        "variance": "Variance",
        "chiSquare": "Chi¬≤",
        "quality": "Quality",
        "legend": "‚úì = test passed, ‚úó = test failed. More stars = better overall quality."
      }
    },
    "sandbox": {
      "title": "Your Number Machine",
      "step": "Step {count}",
      "state": "Current value",
      "nextStep": "Next Step",
      "reset": "Reset",
      "allowedOperations": "Available operations"
    },
    "modulo": {
      "title": "The Modulo Wheel (mod {mod})",
      "value": "Value",
      "reset": "Reset",
      "enterValue": "Enter a number",
      "set": "Set",
      "modBy": "Mod by",
      "prime": "prime"
    },
    "multiplication": {
      "title": "The Multiplication Table",
      "explanation": "{rows} rows of {cols} = {result} total",
      "clear": "Clear"
    },
    "bits": {
      "title": "{count}-Bit Toggle",
      "decimal": "Decimal",
      "binary": "Binary",
      "hex": "Hex",
      "clear": "Clear",
      "max": "Max",
      "range": "Range: {min} to {max}",
      "preview32Title": "What about 32 bits?",
      "preview32Possibilities": "With 32 bits: {count} possible values!",
      "preview32Explanation": "Real PRNGs use 32 bits (or more) for astronomically more possibilities"
    },
    "calculator": {
      "title": "Step Calculator",
      "currentValue": "Current Value",
      "operand": "Number",
      "apply": "Apply",
      "history": "Steps",
      "undo": "Undo",
      "reset": "Reset"
    },
    "candy": {
      "title": "Share the Candy",
      "candies": "Candies",
      "friends": "Friends",
      "leftover": "Leftover!",
      "remainder": "(remainder {r})",
      "insight": "The remainder is what's left when you can't divide evenly. This is exactly what 'mod' (modulo) calculates!"
    },
    "counting": {
      "title": "Counting Step by Step",
      "insight": "Adding 1 each time is the simplest transformation. It's predictable - that's why it's NOT random!"
    },
    "overflow": {
      "title": "8-Bit Odometer",
      "bitLimit": "{bits}-bit limit: 0 to {max}",
      "wrapped": "Overflow! Wrapped to 0",
      "nearMax": "Near Max",
      "tryAdding": "Try adding numbers to see what happens at the limit!",
      "almostThere": "Almost there! Only {remaining} more until overflow...",
      "explanation": "The number got too big! Like a car odometer, it wrapped back to 0."
    },
    "multiState": {
      "title": "Four Dancing Variables",
      "steps": "Steps",
      "possibleStates": "Possible States",
      "step": "Step",
      "mixed": "Variables mixed together!",
      "insight": "4 variables √ó 256 values each = over 4 BILLION possible states!"
    }
  }
}
